{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/errors.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./src/util/logger.js","webpack:///external \"path\"","webpack:///external \"mz\"","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/extend.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/client-methods.js","webpack:///./node_modules/@babel/runtime/helpers/objectSpread.js","webpack:///external \"es6-promisify\"","webpack:///external \"fs\"","webpack:///./src/util/manifest.js","webpack:///./src/util/stdin.js","webpack:///./src/firefox/remote.js","webpack:///external \"firefox-profile\"","webpack:///./src/util/file-filter.js","webpack:///external \"event-to-promise\"","webpack:///external \"bunyan\"","webpack:///./src/cmd/build.js","webpack:///./src/util/desktop-notifier.js","webpack:///external \"camelcase\"","webpack:///./src/extension-runners/index.js","webpack:///./src/firefox/index.js","webpack:///external \"os\"","webpack:///./src/cmd/index.js","webpack:///external \"parse-json\"","webpack:///external \"strip-json-comments\"","webpack:///./src/watcher.js","webpack:///./src/util/artifacts.js","webpack:///./src/firefox/preferences.js","webpack:///external \"readline\"","webpack:///./src/util/temp-dir.js","webpack:///./src/util/is-directory.js","webpack:///./src/config.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/tab.js","webpack:///external \"net\"","webpack:///external \"git-rev-sync\"","webpack:///external \"events\"","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/jsobject.js","webpack:///external \"js-select\"","webpack:///./src/program.js","webpack:///external \"yargs\"","webpack:///external \"watchpack\"","webpack:///external \"debounce\"","webpack:///./src/util/zip-dir.js","webpack:///external \"zip-dir\"","webpack:///external \"es6-error\"","webpack:///external \"mkdirp\"","webpack:///external \"multimatch\"","webpack:///external \"addons-linter\"","webpack:///external \"node-notifier\"","webpack:///external \"fx-runner\"","webpack:///./node_modules/@cliqz-oss/node-firefox-connect/index.js","webpack:///external \"tmp\"","webpack:///./src/util/adb.js","webpack:///external \"adbkit\"","webpack:///external \"sign-addon\"","webpack:///external \"opn\"","webpack:///./src/util/updates.js","webpack:///external \"update-notifier\"","webpack:///external \"require-uncached\"","webpack:///external \"decamelize\"","webpack:///./src/util/file-exists.js","webpack:///./src/main.js","webpack:///./src/cmd/lint.js","webpack:///./src/cmd/run.js","webpack:///external \"es6-promise\"","webpack:///./node_modules/@cliqz-oss/firefox-client/index.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/browser.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/client.js","webpack:///external \"colors\"","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/console.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/memory.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/dom.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/domnode.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/network.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/stylesheets.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/webapps.js","webpack:///external \"child_process\"","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/device.js","webpack:///./node_modules/@cliqz-oss/firefox-client/lib/simulator.js","webpack:///./src/extension-runners/firefox-desktop.js","webpack:///./src/extension-runners/firefox-android.js","webpack:///./src/cmd/sign.js","webpack:///./src/cmd/docs.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","WebExtError","UsageError","InvalidManifest","RemoteTempInstallNotSupported","MultiExtensionsReloadError","onlyErrorsWithCode","isErrorWithCode","es6_error__WEBPACK_IMPORTED_MODULE_0__","es6_error__WEBPACK_IMPORTED_MODULE_0___default","ExtendableError","constructor","message","super","errorsMap","errors","sourceDir","error","String","this","errorsBySourceDir","codeWanted","errorHandler","throwError","Array","isArray","indexOf","code","errno","obj","configurable","writable","ConsoleStream","verbose","_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default","isCapturing","capturedMessages","format","msg","level","nameFromLevel","makeVerbose","write","packet","localProcess","process","thisLevel","bunyan","TRACE","INFO","push","stdout","startCapturing","stopCapturing","flushCapturedLogs","consoleStream","createLogger","filename","createBunyanLog","defaultLogCreator","replace","streams","type","stream","require","properties","getOwnPropertyNames","reduce","descriptor","getOwnPropertyDescriptor","JSObject","events","ClientMethods","extend","EventEmitter","initialize","client","actor","on","from","emit","request","transform","callback","to","makeRequest","resp","err","Error","createJSObject","pluck","prop","target","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","forEach","__filename","getValidatedManifest","getManifestId","path__WEBPACK_IMPORTED_MODULE_0__","path__WEBPACK_IMPORTED_MODULE_0___default","mz__WEBPACK_IMPORTED_MODULE_1__","parse_json__WEBPACK_IMPORTED_MODULE_2__","parse_json__WEBPACK_IMPORTED_MODULE_2___default","strip_json_comments__WEBPACK_IMPORTED_MODULE_3__","strip_json_comments__WEBPACK_IMPORTED_MODULE_3___default","_errors__WEBPACK_IMPORTED_MODULE_4__","_logger__WEBPACK_IMPORTED_MODULE_5__","log","async","manifestFile","path","join","manifestContents","manifestData","debug","fs","readFile","encoding","parseJSON","stripJsonComments","version","applications","gecko","id","undefined","isTTY","setRawMode","rawMode","REMOTE_PORT","RemoteFirefox","checkedForAddonReloading","info","JSON","stringify","disconnect","addonRequest","addon","Promise","resolve","reject","response","installTemporaryAddon","addonPath","tabsResponse","addonsActor","installResponse","getInstalledAddon","addonId","addons","then","map","a","[object Object]","requestTypes","supportedRequestTypes","checkForAddonReloading","Date","toTimeString","connect","port","connectToFirefox","defaultFirefoxConnector","connectWithMaxRetries","maxRetries","retryInterval","lastError","retries","stack","setTimeout","establishConnection","isSubPath","src","relate","relative","startsWith","sep","FileFilter","baseIgnoredPatterns","ignoreFiles","artifactsDir","filesToIgnore","addToIgnoreList","resolveWithSourceDir","file","resolvedPath","files","charAt","resolvedFile","substr","wantFile","filePath","multimatch","createFileFilter","params","safeFileName","getDefaultLocalizedName","defaultPackageCreator","build","fs__WEBPACK_IMPORTED_MODULE_1__","mz__WEBPACK_IMPORTED_MODULE_2__","parse_json__WEBPACK_IMPORTED_MODULE_3__","parse_json__WEBPACK_IMPORTED_MODULE_3___default","strip_json_comments__WEBPACK_IMPORTED_MODULE_4__","strip_json_comments__WEBPACK_IMPORTED_MODULE_4___default","event_to_promise__WEBPACK_IMPORTED_MODULE_5__","event_to_promise__WEBPACK_IMPORTED_MODULE_5___default","_watcher__WEBPACK_IMPORTED_MODULE_6__","_util_zip_dir__WEBPACK_IMPORTED_MODULE_7__","_util_manifest__WEBPACK_IMPORTED_MODULE_8__","_util_artifacts__WEBPACK_IMPORTED_MODULE_9__","_util_logger__WEBPACK_IMPORTED_MODULE_10__","_errors__WEBPACK_IMPORTED_MODULE_11__","_util_file_filter__WEBPACK_IMPORTED_MODULE_12__","toLowerCase","messageFile","messageData","messageContents","extensionName","match","messageName","fileFilter","overwriteDest","showReadyMessage","eventToPromise","defaultEventToPromise","buffer","zipDir","args","default_locale","packageName","extensionPath","createWriteStream","flags","end","asNeeded","defaultFileFilterCreator","onSourceChange","defaultSourceWatcher","packageCreator","rebuildAsNeeded","createPackage","prepareArtifactsDir","result","onChange","catch","shouldWatchFile","showDesktopNotification","node_notifier__WEBPACK_IMPORTED_MODULE_0__","node_notifier__WEBPACK_IMPORTED_MODULE_0___default","_logger__WEBPACK_IMPORTED_MODULE_1__","defaultLog","title","icon","notifier","defaultNotifier","notify","res","createExtensionRunner","config","FirefoxDesktopExtensionRunner","FirefoxAndroidExtensionRunner","MultiExtensionRunner","extensionRunners","runners","desktopNotifications","getName","promises","runner","run","all","reloadPromise","reloadAllExtensions","runnerName","reloadError","results","handleReloadResults","reloadExtensionBySourceDir","registerCleanup","cleanupCallback","exit","_ref","defaultWatcherCreator","reloadExtension","defaultReloadStrategy","extensionRunner","noInput","createWatcher","stdin","kill","allowInput","watcher","watchedSourceDir","close","pause","readline","emitKeypressEvents","keypressUsageInfo","userExit","keyPressed","once","str","ctrl","pid","defaultAsyncFsStat","stat","defaultFirefoxEnv","XPCOM_DEBUG_BREAK","NS_TRACE_MALLOC_DISABLE_STACKS","defaultRemotePortFinder","portToTry","retriesLeft","profile","fxRunner","defaultFxRunner","findRemotePort","firefoxBinary","binaryArgs","remotePort","binary","binary-args","no-remote","listen","foreground","env","_babel_runtime_helpers_objectSpread__WEBPACK_IMPORTED_MODULE_0___default","firefox","stderr","data","toString","trim","debuggerPort","DEFAULT_PROFILES_NAMES","isDefaultProfile","profilePathOrName","ProfileFinder","FirefoxProfile","Finder","fsStat","includes","baseProfileDir","locateUserDirectory","profilesIniPath","finder","readProfiles","promisify","normalizedProfileDirPath","normalize","profiles","Name","Default","profileFullPath","IsRelative","Path","configureProfile","app","getPrefs","defaultPrefGetter","customPrefs","prefs","pref","setPreference","customPrefsStr","custom","updatePreferences","defaultCreateProfileFinder","userDirectoryPath","FxProfile","getPath","profileDef","profileName","warn","useProfile","profilePath","configureThisProfile","isFirefoxDefaultProfile","createProfileFinder","destinationDirectory","getProfilePath","isDirectory","createProfile","copyProfile","profileDirectory","copyFromUserProfile","defaultUserProfileCopier","copy","copyByName","installExtension","asProxy","asyncFsStat","extensionsDir","mkdir","destPath","writeStream","nodeFs","readStream","createReadStream","pipe","options","default","runCommand","lint","sign","docs","watchpack__WEBPACK_IMPORTED_MODULE_0__","watchpack__WEBPACK_IMPORTED_MODULE_0___default","debounce__WEBPACK_IMPORTED_MODULE_1__","debounce__WEBPACK_IMPORTED_MODULE_1___default","_util_logger__WEBPACK_IMPORTED_MODULE_2__","Watchpack","debounce","proxyFileChanges","watch","now","mz__WEBPACK_IMPORTED_MODULE_0__","mkdirp__WEBPACK_IMPORTED_MODULE_1__","mkdirp__WEBPACK_IMPORTED_MODULE_1___default","es6_promisify__WEBPACK_IMPORTED_MODULE_2__","es6_promisify__WEBPACK_IMPORTED_MODULE_2___default","_errors__WEBPACK_IMPORTED_MODULE_3__","_logger__WEBPACK_IMPORTED_MODULE_4__","defaultAsyncMkdirp","mkdirp","defaultAsyncFsAccess","access","asyncMkdirp","asyncFsAccess","W_OK","accessErr","mkdirErr","nonOverridablePreferences","prefsCommon","browser.dom.window.dump.enabled","devtools.debugger.remote-enabled","devtools.debugger.prompt-connection","extensions.logging.enabled","extensions.checkCompatibility.nightly","extensions.update.enabled","extensions.update.notifyUser","extensions.enabledScopes","extensions.getAddons.cache.enabled","extensions.installDistroAddons","extensions.autoDisableScopes","app.update.enabled","xpinstall.signatures.required","common","fennec","browser.console.showInPanel","browser.firstrun.show.uidiscovery","devtools.remote.usb.enabled","browser.startup.homepage","startup.homepage_welcome_url","startup.homepage_welcome_url.additional","devtools.errorconsole.enabled","devtools.chrome.enabled","urlclassifier.updateinterval","browser.safebrowsing.provider.0.gethashURL","browser.safebrowsing.provider.0.keyURL","browser.safebrowsing.provider.0.updateURL","browser.selfsupport.url","browser.reader.detectedFirstArticle","datareporting.policy.firstRunURL","appPrefs","coerceCLICustomPreference","cliPrefs","prefsAry","split","slice","test","parseInt","withTempDir","makePromise","tmpDir","TempDir","successHandler","_path","_removeTempDir","tmp","dir","multiArgs","createTempDir","prefix","unsafeCleanup","tmpPath","removeTempDir","remove","promiseResult","_errors__WEBPACK_IMPORTED_MODULE_1__","stats","applyConfigToArgv","argv","argvFromCLI","configObject","configFileName","newArgv","option","camelCase","decamelizedOptName","decamelize","expectedType","optionType","defaultValue","coerce","loadJSConfigFile","resolvedFilePath","requireUncached","endsWith","webExt","discoverConfigFiles","getHomeDir","os","homedir","possibleConfigs","cwd","configs","resolvedFileName","fileName","fileExists","existingConfigs","f","Console","Memory","DOM","Network","StyleSheets","Tab","tab","updateInfo","onTabNavigated","form","url","_StyleSheets","styleSheetsActor","_DOM","inspectorActor","_Network","consoleActor","_Console","_Memory","memoryActor","event","state","attach","cb","detach","reload","navigateTo","class","displayName","ownPropertyNames","ownPropertyDescriptor","transformDescriptor","ownProperties","transformProperties","ownPropertiesAndPrototype","safeGetterValues","transformGetters","props","transformed","getters","transformGetter","getterValue","prototypeLevel","getterPrototypeLevel","envPrefix","Program","absolutePackageDir","_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default","yargsInstance","yargs","verboseEnabled","shouldExitProgram","strict","commands","command","description","executor","commandOptions","yargsForCmd","demandCommand","exitProcess","setGlobalOptions","global","demand","enableVerboseMode","logStream","checkForUpdates","defaultUpdateChecker","systemProcess","defaultLogStream","getVersion","defaultVersionGetter","defaultApplyConfigToArgv","defaultConfigDiscovery","defaultLoadJSConfigFile","globalEnv","WEBEXT_BUILD_ENV","cmd","_","adjustedArgv","configFiles","configDiscovery","discoveredConfigs","niceFileList","packageData","readFileSync","parse","git","branch","long","main","defaultCommands","runOptions","program","usage","help","alias","source-dir","describe","requiresArg","artifacts-dir","ignore-files","no-input","config-discovery","as-needed","overwrite-dest","api-key","api-secret","api-url-prefix","api-proxy","timeout","channel","firefox-profile","keep-profile-changes","no-reload","pre-install","start-url","browser-console","adb-bin","adb-host","adb-port","adb-device","firefox-apk","output","choices","metadata","warnings-as-errors","pretty","self-hosted","boring","execute","zip_dir__WEBPACK_IMPORTED_MODULE_0__","zip_dir__WEBPACK_IMPORTED_MODULE_0___default","es6_promisify__WEBPACK_IMPORTED_MODULE_1__","zipDirModule","FirefoxClient","wrapADBCall","asyncFn","ADBUtils","adb","adbBin","adbHost","adbPort","defaultADB","adbClient","createClient","bin","host","artifactsDirMap","Map","userAbortDiscovery","runShellCommand","deviceId","shell","util","readAll","devices","listDevices","dev","firefoxApk","line","androidVersion","androidVersionNumber","isNaN","apk","permissions","permissionsMap","perm","pmDumpLogs","set","delete","localPath","devicePath","transfer","deviceProfileDir","startActivity","wait","action","component","extras","setUserAbortDiscovery","maxDiscoveryTime","rdpUnixSockets","discoveryStartedAt","pop","remote","local","forward","update_notifier__WEBPACK_IMPORTED_MODULE_0__","update_notifier__WEBPACK_IMPORTED_MODULE_0___default","updateNotifier","defaultUpdateNotifier","pkg","updateCheckInterval","fileIsReadable","constants","R_OK","isFile","_program__WEBPACK_IMPORTED_MODULE_0__","_cmd__WEBPACK_IMPORTED_MODULE_1__","logger","addons_linter__WEBPACK_IMPORTED_MODULE_0__","_util_logger__WEBPACK_IMPORTED_MODULE_1__","_util_file_filter__WEBPACK_IMPORTED_MODULE_2__","selfHosted","warningsAsErrors","createLinter","defaultLinterCreator","logLevel","Boolean","shouldScanFile","runAsBinary","browserConsole","firefoxProfile","keepProfileChanges","noReload","preInstall","startUrl","adbDevice","buildExtension","defaultBuildExtension","defaultDesktopNotifications","firefoxApp","defaultFirefoxApp","firefoxClient","defaultFirefoxClient","reloadStrategy","DefaultMultiExtensionRunner","defaultGetValidatedManifest","commonRunnerParams","extensions","firefoxDesktopRunnerParams","firefoxDesktopRunner","firefoxAndroidRunnerParams","buildSourceDir","extensionSourceDir","tmpArtifactsDir","firefoxAndroidRunner","Client","Webapps","Device","SimulatorApps","onError","onEnd","onTimeout","expectReply","selectedTab","tabs","selected","listTabs","simulatorWebappsActor","listApps","getWebapps","webapps","getDevice","device","getRoot","root","net","unsolicitedEvents","tabNavigated","styleApplied","propertyChange","networkEventUpdate","networkEvent","newMutations","appOpen","appClose","appInstall","appUninstall","frameUpdate","tabListChanged","incoming","Buffer","_pendingRequests","_activeRequests","createConnection","onData","green","_flushRequests","sendMessage","handler","uneval","handleMessage","grey","yellow","readMessage","count","e","red","console","select","onConsoleAPI","onPageError","types","startListening","listeners","stopListening","transformConsoleCall","pageError","getCachedLogs","messageTypes","update","messages","clearCachedLogs","evaluateJS","text","measure","Node","walker","Walker","Style","style","document","walkerRequest","node","documentElement","querySelector","selector","querySelectorAll","getComputedStyle","styleRequest","getUsedFontFaces","includePreviews","previewText","previewFontSize","getFontPreview","font","getWalker","getStyle","pageStyle","getNode","getNodeArray","getNodeList","attr","NodeList","list","getAttribute","attrs","setAttribute","mods","attributeName","newValue","modifications","parentNode","parents","nodes","nodeRequest","children","siblings","nextSibling","previousSibling","getUniqueSelector","innerHTML","outerHTML","highlight","release","items","start","onNetworkEvent","NetworkEvent","onUpdate","startLogging","stopLogging","eventActor","sendHTTPRequest","method","isXHR","getRequestHeaders","getRequestCookies","getRequestPostData","getResponseHeaders","getResponseCookies","getResponseContent","getEventTimings","requestHeaders","requestCookies","requestPostData","responseStart","responseHeaders","responseCookies","responseContent","eventTimings","updateType","StyleSheet","sheet","onPropertyChange","MediaRule","rule","matches","OriginalSource","getStyleSheets","styleSheets","addStyleSheet","styleSheet","href","disabled","ruleCount","toggleDisabled","getOriginalSources","originalSources","getMediaRules","mediaRules","transition","getText","mediaText","spawn","CHUNK_SIZE","webappsActor","watchApps","unwatchApps","launch","manifestURL","getInstalledApps","apps","listRunningApps","getApp","installHosted","appId","manifest","_upload","chunk","self","step","Math","min","fromCharCode","done","installPackaged","cleanup","upload","installPackagedWithADB","uploadPackage","stdio","installApp","uninstall","deviceActor","getDescription","getRawPermissionsTable","rawPermissionsTable","reloadableExtensions","cleanupCallbacks","Set","setupProfileDir","startFirefoxInstance","reloadErrors","size","remoteFirefox","reloadAddon","fn","add","runningInfo","extension","urls","cleanupCb","installResult","adbExtensionsPathBySourceDir","printIgnoredParamsWarnings","DefaultADBUtils","adbUtils","adbDevicesDiscoveryAndSelect","apkPackagesDiscoveryAndSelect","adbCheckRuntimePermissions","adbForceStopSelectedPackage","adbPrepareProfileDir","adbStartSelectedPackage","buildAndPushExtensions","adbDiscoveryAndForwardRDPUnixSocket","rdpInstallExtensions","buildAndPushExtension","selectedAdbDevice","selectedArtifactsDir","exiting","clearArtifactsDir","getDeviceProfileDir","discoverDevices","devicesMsg","foundDevices","packages","discoverInstalledFirefoxAPKs","pkgsListMsg","pkgs","selectedFirefoxApk","filteredPackages","pkgsList","amForceStopAPK","getAndroidVersionNumber","Number","ensureRequiredAPKRuntimePermissions","getOrCreateArtifactsDir","pushFile","profileDir","startFirefoxAPK","extFileName","basename","adbExtensionPath","_ref2","firefoxAndroidTimeout","unixSocketDiscoveryRetryInterval","unixSocketDiscoveryMaxTime","handleCtrlC","selectedRDPSocketFile","discoverRDPUnixSocket","removeListener","tcpPort","chooseLocalTcpPort","forwardSocketSpec","setupForward","selectedTCPPort","srv","createServer","freeTcpPort","address","extensionIdFile","getIdFromSourceDir","saveIdToSourceDir","sign_addon__WEBPACK_IMPORTED_MODULE_2__","sign_addon__WEBPACK_IMPORTED_MODULE_2___default","_build__WEBPACK_IMPORTED_MODULE_3__","_util_manifest__WEBPACK_IMPORTED_MODULE_4__","_util_temp_dir__WEBPACK_IMPORTED_MODULE_5__","_errors__WEBPACK_IMPORTED_MODULE_6__","_util_artifacts__WEBPACK_IMPORTED_MODULE_7__","_util_logger__WEBPACK_IMPORTED_MODULE_8__","defaultAsyncFsReadFile","apiKey","apiProxy","apiSecret","apiUrlPrefix","defaultBuilder","preValidatedManifest","signAddon","defaultAddonSigner","buildResult","idFromSourceDir","manifestId","signingResult","xpiPath","downloadDir","success","asyncFsReadFile","content","lines","writeFile","opn__WEBPACK_IMPORTED_MODULE_0__","opn__WEBPACK_IMPORTED_MODULE_0___default","openUrl","opn"],"mappings":"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","file":"web-ext.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 62);\n","/* @flow */\nimport ExtendableError from 'es6-error';\n\n\n/*\n * Base error for all custom web-ext errors.\n */\nexport class WebExtError extends ExtendableError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The class for errors that can be fixed by the developer.\n */\nexport class UsageError extends WebExtError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The manifest for the extension is invalid (or missing).\n */\nexport class InvalidManifest extends UsageError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n\n/*\n * The remote Firefox does not support temporary add-on installation.\n */\nexport class RemoteTempInstallNotSupported extends WebExtError {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/*\n * The errors collected when reloading all extensions at once\n * (initialized from a map of errors by extensionSourceDir string).\n */\nexport class MultiExtensionsReloadError extends WebExtError {\n  constructor(errorsMap: Map<string, Error>) {\n    let errors = '';\n    for (const [sourceDir, error] of errorsMap) {\n      const msg = String(error);\n      errors += `\\nError on extension loaded from ${sourceDir}: ${msg}\\n`;\n    }\n    const message = `Reload errors: ${errors}`;\n\n    super(message);\n    this.errorsBySourceDir = errorsMap;\n  }\n}\n\n/*\n * Sugar-y way to catch only instances of a certain error.\n *\n * Usage:\n *\n *  Promise.reject(SyntaxError)\n *    .catch(onlyInstancesOf(SyntaxError, (error) => {\n *      // error is guaranteed to be an instance of SyntaxError\n *    }))\n *\n * All other errors will be re-thrown.\n *\n */\nexport function onlyInstancesOf(\n  predicate: Function, errorHandler: Function\n): Function {\n  return (error) => {\n    if (error instanceof predicate) {\n      return errorHandler(error);\n    } else {\n      throw error;\n    }\n  };\n}\n\n\n/*\n * Sugar-y way to catch only errors having certain code(s).\n *\n * Usage:\n *\n *  Promise.resolve()\n *    .catch(onlyErrorsWithCode('ENOENT', (error) => {\n *      // error.code is guaranteed to be ENOENT\n *    }))\n *\n *  or:\n *\n *  Promise.resolve()\n *    .catch(onlyErrorsWithCode(['ENOENT', 'ENOTDIR'], (error) => {\n *      // ...\n *    }))\n *\n * All other errors will be re-thrown.\n *\n */\nexport function onlyErrorsWithCode(\n  codeWanted: (string | number) | Array<string | number>,\n  errorHandler: Function\n): Function {\n  return (error) => {\n    let throwError = true;\n\n    if (Array.isArray(codeWanted)) {\n      if (codeWanted.indexOf(error.code) !== -1 ||\n          codeWanted.indexOf(error.errno) !== -1) {\n        throwError = false;\n      }\n    } else if (error.code === codeWanted || error.errno === codeWanted) {\n      throwError = false;\n    }\n\n    if (throwError) {\n      throw error;\n    }\n\n    return errorHandler(error);\n  };\n}\n\nexport function isErrorWithCode(\n  codeWanted: string | Array<string>,\n  error: Object,\n): boolean {\n  if (Array.isArray(codeWanted) && codeWanted.indexOf(error.code) !== -1) {\n    return true;\n  } else if (error.code === codeWanted) {\n    return true;\n  }\n\n  return false;\n}\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","/* @flow */\nimport bunyan, {nameFromLevel, createLogger as defaultLogCreator}\n  from 'bunyan';\n\n\n// Bunyan-related Flow types\n\nexport type TRACE = 10;\nexport type DEBUG = 20;\nexport type INFO = 30;\nexport type WARN = 40;\nexport type ERROR = 50;\nexport type FATAL = 60;\n\nexport type BunyanLogLevel =\n  TRACE | DEBUG | INFO | WARN | ERROR | FATAL;\n\nexport type BunyanLogEntry = {|\n  name: string,\n  msg: string,\n  level: BunyanLogLevel,\n|};\n\nexport type Logger = {\n  debug: (msg: string, ...args: any) => void,\n  error: (msg: string, ...args: any) => void,\n  info: (msg: string, ...args: any) => void,\n  warn: (msg: string, ...args: any) => void,\n};\n\n\n// ConsoleStream types and implementation.\n\nexport type ConsoleStreamParams = {|\n  verbose?: boolean,\n|};\n\nexport type ConsoleOptions = {|\n  localProcess?: typeof process,\n|};\n\nexport class ConsoleStream {\n  verbose: boolean;\n  isCapturing: boolean;\n  capturedMessages: Array<string>;\n\n  constructor({verbose = false}: ConsoleStreamParams = {}) {\n    this.verbose = verbose;\n    this.isCapturing = false;\n    this.capturedMessages = [];\n  }\n\n  format({name, msg, level}: BunyanLogEntry): string {\n    const prefix = this.verbose ? `[${name}][${nameFromLevel[level]}] ` : '';\n    return `${prefix}${msg}\\n`;\n  }\n\n  makeVerbose() {\n    this.verbose = true;\n  }\n\n  write(\n    packet: BunyanLogEntry,\n    {localProcess = process}: ConsoleOptions = {}\n  ): void {\n    const thisLevel: BunyanLogLevel = this.verbose ? bunyan.TRACE : bunyan.INFO;\n    if (packet.level >= thisLevel) {\n      const msg = this.format(packet);\n      if (this.isCapturing) {\n        this.capturedMessages.push(msg);\n      } else {\n        localProcess.stdout.write(msg);\n      }\n    }\n  }\n\n  startCapturing() {\n    this.isCapturing = true;\n  }\n\n  stopCapturing() {\n    this.isCapturing = false;\n    this.capturedMessages = [];\n  }\n\n  flushCapturedLogs({localProcess = process}: ConsoleOptions = {}) {\n    for (const msg of this.capturedMessages) {\n      localProcess.stdout.write(msg);\n    }\n    this.capturedMessages = [];\n  }\n}\n\nexport const consoleStream = new ConsoleStream();\n\n\n// createLogger types and implementation.\n\nexport type BunyanStreamConfig = {|\n  type: string,\n  stream: ConsoleStream,\n|};\n\nexport type CreateBunyanLogParams = {|\n  name: string,\n  level: BunyanLogLevel,\n  streams: Array<BunyanStreamConfig>,\n|};\n\nexport type CreateBunyanLogFn = (params: CreateBunyanLogParams) => Logger;\n\nexport type CreateLoggerOptions = {|\n  createBunyanLog: CreateBunyanLogFn,\n|};\n\nexport function createLogger(\n  filename: string,\n  {createBunyanLog = defaultLogCreator}: CreateLoggerOptions = {}\n): Logger {\n  return createBunyanLog({\n    // Strip the leading src/ from file names (which is in all file names) to\n    // make the name less redundant.\n    name: filename.replace(/^src\\//, ''),\n    // Capture all log levels and let the stream filter them.\n    level: bunyan.TRACE,\n    streams: [{\n      type: 'raw',\n      stream: consoleStream,\n    }],\n  });\n}\n","module.exports = require(\"path\");","module.exports = require(\"mz\");","module.exports = function extend(prototype, properties) {\n  return Object.create(prototype, getOwnPropertyDescriptors(properties));\n}\n\nfunction getOwnPropertyDescriptors(object) {\n  var names = Object.getOwnPropertyNames(object);\n\n  return names.reduce(function(descriptor, name) {\n    descriptor[name] = Object.getOwnPropertyDescriptor(object, name);\n    return descriptor;\n  }, {});\n}","var events = require(\"events\"),\n    extend = require(\"./extend\");\n\n// to be instantiated later - to avoid circular dep resolution\nvar JSObject;\n\nvar ClientMethods = extend(events.EventEmitter.prototype, {\n  /**\n   * Intialize this client object.\n   *\n   * @param  {object} client\n   *         Client to send requests on.\n   * @param  {string} actor\n   *         Actor id to set as 'from' field on requests\n   */\n  initialize: function(client, actor) {\n    this.client = client;\n    this.actor = actor;\n\n    this.client.on('message', function(message) {\n      if (message.from == this.actor) {\n        this.emit(message.type, message);\n      }\n    }.bind(this));\n  },\n\n  /**\n   * Make request to our actor on the server.\n   *\n   * @param  {string}   type\n   *         Method name of the request\n   * @param  {object}   message\n   *         Optional extra properties (arguments to method)\n   * @param  {Function}   transform\n   *         Optional tranform for response object. Takes response object\n   *         and returns object to send on.\n   * @param  {Function} callback\n   *         Callback to call with (maybe transformed) response\n   */\n  request: function(type, message, transform, callback) {\n    if (typeof message == \"function\") {\n      if (typeof transform == \"function\") {\n        // (type, trans, cb)\n        callback = transform;\n        transform = message;\n      }\n      else {\n        // (type, cb)\n        callback = message;\n      }\n      message = {};\n    }\n    else if (!callback) {\n      if (!message) {\n        // (type)\n        message = {};\n      }\n      // (type, message, cb)\n      callback = transform;\n      transform = null;\n    }\n\n    message.to = this.actor;\n    message.type = type;\n\n    this.client.makeRequest(message, function(resp) {\n      delete resp.from;\n\n      if (resp.error) {\n        var err = new Error(resp.message);\n        err.name = resp.error;\n\n        callback(err);\n        return;\n      }\n\n      if (transform) {\n        resp = transform(resp);\n      }\n\n      if (callback) {\n        callback(null, resp);\n      }\n    });\n  },\n\n  /*\n   * Transform obj response into a JSObject\n   */\n  createJSObject: function(obj) {\n    if (obj == null) {\n      return;\n    }\n    if (!JSObject) {\n      // circular dependencies\n      JSObject = require(\"./jsobject\");\n    }\n    if (obj.type == \"object\") {\n      return new JSObject(this.client, obj);\n    }\n    return obj;\n  },\n\n  /**\n   * Create function that plucks out only one value from an object.\n   * Used as the transform function for some responses.\n   */\n  pluck: function(prop) {\n    return function(obj) {\n      return obj[prop];\n    }\n  }\n})\n\nmodule.exports = ClientMethods;","var defineProperty = require(\"./defineProperty\");\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread;","module.exports = require(\"es6-promisify\");","module.exports = require(\"fs\");","/* @flow */\nimport path from 'path';\n\nimport {fs} from 'mz';\nimport parseJSON from 'parse-json';\nimport stripJsonComments from 'strip-json-comments';\n\nimport {InvalidManifest} from '../errors';\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\n\n// getValidatedManifest helper types and implementation\n\nexport type ExtensionManifestApplications = {|\n  gecko: {|\n    id?: string,\n    strict_min_version?: string,\n    strict_max_version?: string,\n    update_url?: string,\n  |},\n|};\n\nexport type ExtensionManifest = {|\n  name: string,\n  version: string,\n  default_locale?: string,\n  applications?: ExtensionManifestApplications,\n|};\n\nexport default async function getValidatedManifest(\n  sourceDir: string\n): Promise<ExtensionManifest> {\n  const manifestFile = path.join(sourceDir, 'manifest.json');\n  log.debug(`Validating manifest at ${manifestFile}`);\n\n  let manifestContents;\n\n  try {\n    manifestContents = await fs.readFile(manifestFile, {encoding: 'utf-8'});\n  } catch (error) {\n    throw new InvalidManifest(\n      `Could not read manifest.json file at ${manifestFile}: ${error}`);\n  }\n\n  let manifestData;\n\n  try {\n    manifestData = parseJSON(stripJsonComments(manifestContents), manifestFile);\n  } catch (error) {\n    throw new InvalidManifest(\n      `Error parsing manifest.json at ${manifestFile}: ${error}`);\n  }\n\n  const errors = [];\n  // This is just some basic validation of what web-ext needs, not\n  // what Firefox will need to run the extension.\n  // TODO: integrate with the addons-linter for actual validation.\n  if (!manifestData.name) {\n    errors.push('missing \"name\" property');\n  }\n  if (!manifestData.version) {\n    errors.push('missing \"version\" property');\n  }\n\n  if (manifestData.applications && !manifestData.applications.gecko) {\n    // Since the applications property only applies to gecko, make\n    // sure 'gecko' exists when 'applications' is defined. This should\n    // make introspection of gecko properties easier.\n    errors.push('missing \"applications.gecko\" property');\n  }\n\n  if (errors.length) {\n    throw new InvalidManifest(\n      `Manifest at ${manifestFile} is invalid: ${errors.join('; ')}`);\n  }\n\n  return manifestData;\n}\n\n\nexport function getManifestId(manifestData: ExtensionManifest): string | void {\n  return manifestData.applications ?\n    manifestData.applications.gecko.id : undefined;\n}\n","/* @flow */\n\nimport type {Readable} from 'stream';\n\nexport function isTTY(stream: Readable): boolean {\n  // $FLOW_FIXME: flow complains that stream may not provide isTTY as a property.\n  return stream.isTTY;\n}\n\nexport function setRawMode(stream: Readable, rawMode: boolean) {\n  // $FLOW_FIXME: flow complains that stdin may not provide setRawMode.\n  stream.setRawMode(rawMode);\n}\n","/* @flow */\nimport defaultFirefoxConnector from '@cliqz-oss/node-firefox-connect';\n// RemoteFirefox types and implementation\nimport type FirefoxClient from '@cliqz-oss/firefox-client';\n\nimport {createLogger} from '../util/logger';\nimport {\n  isErrorWithCode,\n  RemoteTempInstallNotSupported,\n  UsageError,\n  WebExtError,\n} from '../errors';\n\nconst log = createLogger(__filename);\n\n// The default port that Firefox's remote debugger will listen on and the\n// client will connect to.\nexport const REMOTE_PORT = 6005;\n\nexport type FirefoxConnectorFn =\n  (port?: number) => Promise<FirefoxClient>;\n\nexport type FirefoxRDPAddonActor = {|\n  id: string,\n  actor: string,\n|};\n\nexport type FirefoxRDPResponseError = {|\n  error: {\n    message: string,\n  },\n|};\n\nexport type FirefoxRDPResponseAddon = {|\n  addon: FirefoxRDPAddonActor,\n|};\n\nexport type FirefoxRDPResponseRequestTypes = {|\n  requestTypes: Array<string>,\n|};\n\n// NOTE: this type aliases Object to catch any other possible response.\nexport type FirefoxRDPResponseAny = Object;\n\nexport type FirefoxRDPResponseMaybe =\n  FirefoxRDPResponseRequestTypes | FirefoxRDPResponseAny;\n\nexport class RemoteFirefox {\n  client: Object;\n  checkedForAddonReloading: boolean;\n\n  constructor(client: FirefoxClient) {\n    this.client = client;\n    this.checkedForAddonReloading = false;\n\n    client.client.on('disconnect', () => {\n      log.debug('Received \"disconnect\" from Firefox client');\n    });\n    client.client.on('end', () => {\n      log.debug('Received \"end\" from Firefox client');\n    });\n    client.client.on('message', (info) => {\n      // These are arbitrary messages that the client library ignores.\n      log.debug(`Received message from client: ${JSON.stringify(info)}`);\n    });\n  }\n\n  disconnect() {\n    this.client.disconnect();\n  }\n\n  addonRequest(\n    addon: FirefoxRDPAddonActor,\n    request: string\n  ): Promise<FirefoxRDPResponseMaybe> {\n    return new Promise((resolve, reject) => {\n      this.client.client.makeRequest(\n        {to: addon.actor, type: request}, (response) => {\n          if (response.error) {\n            const error = `${response.error}: ${response.message}`;\n            log.debug(\n              `Client responded to '${request}' request with error:`, error);\n            reject(new WebExtError(error));\n          } else {\n            resolve(response);\n          }\n        });\n    });\n  }\n\n  installTemporaryAddon(\n    addonPath: string\n  ): Promise<FirefoxRDPResponseAddon> {\n    return new Promise((resolve, reject) => {\n      this.client.request('listTabs', (error, tabsResponse) => {\n        if (error) {\n          return reject(new WebExtError(\n            `Remote Firefox: listTabs() error: ${error}`));\n        }\n        if (!tabsResponse.addonsActor) {\n          log.debug(\n            'listTabs returned a falsey addonsActor: ' +\n            `${tabsResponse.addonsActor}`);\n          return reject(new RemoteTempInstallNotSupported(\n            'This is an older version of Firefox that does not provide an ' +\n            'add-ons actor for remote installation. Try Firefox 49 or ' +\n            'higher.'));\n        }\n\n        this.client.client.makeRequest({\n          to: tabsResponse.addonsActor,\n          type: 'installTemporaryAddon',\n          addonPath,\n        }, (installResponse) => {\n          if (installResponse.error) {\n            return reject(new WebExtError(\n              'installTemporaryAddon: Error: ' +\n              `${installResponse.error}: ${installResponse.message}`));\n          }\n          log.debug(\n            `installTemporaryAddon: ${JSON.stringify(installResponse)}`);\n          log.info(`Installed ${addonPath} as a temporary add-on`);\n          resolve(installResponse);\n        });\n      });\n    });\n  }\n\n  getInstalledAddon(addonId: string): Promise<FirefoxRDPAddonActor> {\n    return new Promise(\n      (resolve, reject) => {\n        this.client.request('listAddons', (error, response) => {\n          if (error) {\n            reject(new WebExtError(\n              `Remote Firefox: listAddons() error: ${error}`));\n          } else {\n            resolve(response.addons);\n          }\n        });\n      })\n      .then((addons) => {\n        for (const addon of addons) {\n          if (addon.id === addonId) {\n            return addon;\n          }\n        }\n        log.debug(\n          `Remote Firefox has these addons: ${addons.map((a) => a.id)}`);\n        throw new WebExtError(\n          'The remote Firefox does not have your extension installed');\n      });\n  }\n\n  async checkForAddonReloading(\n    addon: FirefoxRDPAddonActor\n  ): Promise<FirefoxRDPAddonActor> {\n    if (this.checkedForAddonReloading) {\n      // We only need to check once if reload() is supported.\n      return addon;\n    } else {\n      const response = await this.addonRequest(addon, 'requestTypes');\n\n      if (response.requestTypes.indexOf('reload') === -1) {\n        const supportedRequestTypes = JSON.stringify(response.requestTypes);\n        log.debug(\n          `Remote Firefox only supports: ${supportedRequestTypes}`);\n        throw new UsageError(\n          'This Firefox version does not support add-on reloading. ' +\n          'Re-run with --no-reload');\n      } else {\n        this.checkedForAddonReloading = true;\n        return addon;\n      }\n    }\n  }\n\n  async reloadAddon(addonId: string): Promise<void> {\n    const addon = await this.getInstalledAddon(addonId);\n    await this.checkForAddonReloading(addon);\n    await this.addonRequest(addon, 'reload');\n    process.stdout.write(\n      `\\rLast extension reload: ${(new Date()).toTimeString()}`);\n    log.debug('\\n');\n  }\n}\n\n\n// Connect types and implementation\n\nexport type ConnectOptions = {|\n  connectToFirefox: FirefoxConnectorFn,\n|};\n\nexport async function connect(\n  port: number = REMOTE_PORT,\n  {connectToFirefox = defaultFirefoxConnector}: ConnectOptions = {}\n): Promise<RemoteFirefox> {\n  log.debug(`Connecting to Firefox on port ${port}`);\n  const client = await connectToFirefox(port);\n  log.debug(`Connected to the remote Firefox debugger on port ${port}`);\n  return new RemoteFirefox(client);\n}\n\n\n// ConnectWithMaxRetries types and implementation\n\nexport type ConnectWithMaxRetriesParams = {|\n  maxRetries?: number,\n  retryInterval?: number,\n  port: number,\n|};\n\nexport type ConnectWithMaxRetriesDeps = {|\n  connectToFirefox: typeof connect,\n|};\n\nexport async function connectWithMaxRetries(\n  // A max of 250 will try connecting for 30 seconds.\n  {maxRetries = 250, retryInterval = 120, port}: ConnectWithMaxRetriesParams,\n  {connectToFirefox = connect}: ConnectWithMaxRetriesDeps = {}\n): Promise<RemoteFirefox> {\n  async function establishConnection() {\n    var lastError;\n\n    for (let retries = 0; retries <= maxRetries; retries++) {\n      try {\n        return await connectToFirefox(port);\n      } catch (error) {\n        if (isErrorWithCode('ECONNREFUSED', error)) {\n          // Wait for `retryInterval` ms.\n          await new Promise((resolve) => {\n            setTimeout(resolve, retryInterval);\n          });\n\n          lastError = error;\n          log.debug(\n            `Retrying Firefox (${retries}); connection error: ${error}`);\n        } else {\n          log.error(error.stack);\n          throw error;\n        }\n      }\n    }\n\n    log.debug('Connect to Firefox debugger: too many retries');\n    throw lastError;\n  }\n\n  log.debug('Connecting to the remote Firefox debugger');\n  return establishConnection();\n}\n","module.exports = require(\"firefox-profile\");","/* @flow */\nimport path from 'path';\n\nimport multimatch from 'multimatch';\n\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\n// check if target is a sub directory of src\nexport const isSubPath = (src: string, target: string): boolean => {\n  const relate = path.relative(src, target);\n  // same dir\n  if (!relate) {\n    return false;\n  }\n  if (relate === '..') {\n    return false;\n  }\n  return !relate.startsWith(`..${path.sep}`);\n};\n\n// FileFilter types and implementation.\n\nexport type FileFilterOptions = {|\n  baseIgnoredPatterns?: Array<string>,\n  ignoreFiles?: Array<string>,\n  sourceDir: string,\n  artifactsDir?: string,\n|};\n\n/*\n * Allows or ignores files.\n */\nexport class FileFilter {\n  filesToIgnore: Array<string>;\n  sourceDir: string;\n\n  constructor({\n    baseIgnoredPatterns = [\n      '**/*.xpi',\n      '**/*.zip',\n      '**/.*', // any hidden file and folder\n      '**/.*/**/*', // and the content inside hidden folder\n      '**/node_modules',\n      '**/node_modules/**/*',\n    ],\n    ignoreFiles = [],\n    sourceDir,\n    artifactsDir,\n  }: FileFilterOptions = {}) {\n    sourceDir = path.resolve(sourceDir);\n\n    this.filesToIgnore = [];\n    this.sourceDir = sourceDir;\n\n    this.addToIgnoreList(baseIgnoredPatterns);\n    if (ignoreFiles) {\n      this.addToIgnoreList(ignoreFiles);\n    }\n    if (artifactsDir && isSubPath(sourceDir, artifactsDir)) {\n      artifactsDir = path.resolve(artifactsDir);\n      log.debug(\n        `Ignoring artifacts directory \"${artifactsDir}\" ` +\n        'and all its subdirectories'\n      );\n      this.addToIgnoreList([\n        artifactsDir,\n        path.join(artifactsDir, '**', '*'),\n      ]);\n    }\n  }\n\n  /**\n   *  Resolve relative path to absolute path with sourceDir.\n   */\n  resolveWithSourceDir(file: string): string {\n    const resolvedPath = path.resolve(this.sourceDir, file);\n    log.debug(\n      `Resolved path ${file} with sourceDir ${this.sourceDir} ` +\n      `to ${resolvedPath}`\n    );\n    return resolvedPath;\n  }\n\n  /**\n   *  Insert more files into filesToIgnore array.\n   */\n  addToIgnoreList(files: Array<string>) {\n    for (const file of files) {\n      if (file.charAt(0) === '!') {\n        const resolvedFile = this.resolveWithSourceDir(file.substr(1));\n        this.filesToIgnore.push(`!${resolvedFile}`);\n      } else {\n        this.filesToIgnore.push(this.resolveWithSourceDir(file));\n      }\n    }\n  }\n\n  /*\n   * Returns true if the file is wanted.\n   *\n   * If filePath does not start with a slash, it will be treated as a path\n   * relative to sourceDir when matching it against all configured\n   * ignore-patterns.\n   *\n   * Example: this is called by zipdir as wantFile(filePath) for each\n   * file in the folder that is being archived.\n   */\n  wantFile(filePath: string): boolean {\n    const resolvedPath = this.resolveWithSourceDir(filePath);\n    const matches = multimatch(resolvedPath, this.filesToIgnore);\n    if (matches.length > 0) {\n      log.debug(`FileFilter: ignoring file ${resolvedPath}`);\n      return false;\n    }\n    return true;\n  }\n}\n\n// a helper function to make mocking easier\n\nexport const createFileFilter = (\n  (params: FileFilterOptions): FileFilter => new FileFilter(params)\n);\n\nexport type FileFilterCreatorFn = typeof createFileFilter;\n","module.exports = require(\"event-to-promise\");","module.exports = require(\"bunyan\");","/* @flow */\nimport path from 'path';\nimport {createWriteStream} from 'fs';\n\nimport {fs} from 'mz';\nimport parseJSON from 'parse-json';\nimport stripJsonComments from 'strip-json-comments';\nimport defaultEventToPromise from 'event-to-promise';\n\nimport defaultSourceWatcher from '../watcher';\nimport {zipDir} from '../util/zip-dir';\nimport getValidatedManifest, {getManifestId} from '../util/manifest';\nimport {prepareArtifactsDir} from '../util/artifacts';\nimport {createLogger} from '../util/logger';\nimport {UsageError, isErrorWithCode} from '../errors';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n  FileFilter,\n} from '../util/file-filter';\n// Import flow types.\nimport type {OnSourceChangeFn} from '../watcher';\nimport type {ExtensionManifest} from '../util/manifest';\nimport type {FileFilterCreatorFn} from '../util/file-filter';\n\nconst log = createLogger(__filename);\n\n\nexport function safeFileName(name: string): string {\n  return name.toLowerCase().replace(/[^a-z0-9.-]+/g, '_');\n}\n\n\n// defaultPackageCreator types and implementation.\n\nexport type ExtensionBuildResult = {|\n  extensionPath: string,\n|};\n\nexport type PackageCreatorParams = {|\n  manifestData?: ExtensionManifest,\n  sourceDir: string,\n  fileFilter: FileFilter,\n  artifactsDir: string,\n  overwriteDest: boolean,\n  showReadyMessage: boolean\n|};\n\nexport type LocalizedNameParams = {|\n  messageFile: string,\n  manifestData: ExtensionManifest,\n|}\n\nexport type PackageCreatorOptions = {|\n  eventToPromise: typeof defaultEventToPromise,\n|};\n\n// This defines the _locales/messages.json type. See:\n// https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Internationalization#Providing_localized_strings_in__locales\ntype LocalizedMessageData = {|\n  [messageName: string]: {|\n    description: string,\n    message: string,\n  |},\n|}\n\nexport async function getDefaultLocalizedName(\n  {messageFile, manifestData}: LocalizedNameParams\n): Promise<string> {\n\n  let messageData: LocalizedMessageData;\n  let messageContents: string | Buffer;\n  let extensionName: string = manifestData.name;\n\n  try {\n    messageContents = await fs.readFile(messageFile, {encoding: 'utf-8'});\n  } catch (error) {\n    throw new UsageError(\n      `Error reading messages.json file at ${messageFile}: ${error}`);\n  }\n\n  try {\n    messageData = parseJSON(stripJsonComments(messageContents), messageFile);\n  } catch (error) {\n    throw new UsageError(\n      `Error parsing messages.json ${error}`);\n  }\n\n  extensionName = manifestData.name.replace(\n    /__MSG_([A-Za-z0-9@_]+?)__/g,\n    (match, messageName) => {\n      if (!(messageData[messageName]\n            && messageData[messageName].message)) {\n        const error = new UsageError(\n          `The locale file ${messageFile} ` +\n            `is missing key: ${messageName}`);\n        throw error;\n      } else {\n        return messageData[messageName].message;\n      }\n    });\n  return Promise.resolve(extensionName);\n}\n\nexport type PackageCreatorFn =\n    (params: PackageCreatorParams) => Promise<ExtensionBuildResult>;\n\nexport async function defaultPackageCreator(\n  {\n    manifestData,\n    sourceDir,\n    fileFilter,\n    artifactsDir,\n    overwriteDest,\n    showReadyMessage,\n  }: PackageCreatorParams,\n  {\n    eventToPromise = defaultEventToPromise,\n  }: PackageCreatorOptions = {}\n): Promise<ExtensionBuildResult> {\n  let id;\n  if (manifestData) {\n    id = getManifestId(manifestData);\n    log.debug(`Using manifest id=${id || '[not specified]'}`);\n  } else {\n    manifestData = await getValidatedManifest(sourceDir);\n  }\n\n  const buffer = await zipDir(sourceDir, {\n    filter: (...args) => fileFilter.wantFile(...args),\n  });\n\n  let extensionName: string = manifestData.name;\n\n  if (manifestData.default_locale) {\n    const messageFile = path.join(\n      sourceDir, '_locales',\n      manifestData.default_locale, 'messages.json'\n    );\n    log.debug('Manifest declared default_locale, localizing extension name');\n    extensionName = await getDefaultLocalizedName({\n      messageFile, manifestData,\n    });\n  }\n  const packageName = safeFileName(\n    `${extensionName}-${manifestData.version}.zip`);\n  const extensionPath = path.join(artifactsDir, packageName);\n\n  // Added 'wx' flags to avoid overwriting of existing package.\n  let stream = createWriteStream(extensionPath, {flags: 'wx'});\n\n  stream.write(buffer, () => stream.end());\n\n  try {\n    await eventToPromise(stream, 'close');\n  } catch (error) {\n    if (!isErrorWithCode('EEXIST', error)) {\n      throw error;\n    }\n    if (!overwriteDest) {\n      throw new UsageError(\n        `Extension exists at the destination path: ${extensionPath}\\n` +\n        'Use --overwrite-dest to enable overwriting.');\n    }\n    log.info(`Destination exists, overwriting: ${extensionPath}`);\n    stream = createWriteStream(extensionPath);\n    stream.write(buffer, () => stream.end());\n    await eventToPromise(stream, 'close');\n  }\n\n  if (showReadyMessage) {\n    log.info(`Your web extension is ready: ${extensionPath}`);\n  }\n  return {extensionPath};\n}\n\n\n// Build command types and implementation.\n\nexport type BuildCmdParams = {|\n  sourceDir: string,\n  artifactsDir: string,\n  asNeeded?: boolean,\n  overwriteDest?: boolean,\n  ignoreFiles?: Array<string>,\n|};\n\nexport type BuildCmdOptions = {|\n  manifestData?: ExtensionManifest,\n  fileFilter?: FileFilter,\n  onSourceChange?: OnSourceChangeFn,\n  packageCreator?: PackageCreatorFn,\n  showReadyMessage?: boolean,\n  createFileFilter?: FileFilterCreatorFn,\n  shouldExitProgram?: boolean,\n|};\n\nexport default async function build(\n  {\n    sourceDir,\n    artifactsDir,\n    asNeeded = false,\n    overwriteDest = false,\n    ignoreFiles = [],\n  }: BuildCmdParams,\n  {\n    manifestData,\n    createFileFilter = defaultFileFilterCreator,\n    fileFilter = createFileFilter({\n      sourceDir,\n      artifactsDir,\n      ignoreFiles,\n    }),\n    onSourceChange = defaultSourceWatcher,\n    packageCreator = defaultPackageCreator,\n    showReadyMessage = true,\n  }: BuildCmdOptions = {}\n): Promise<ExtensionBuildResult> {\n\n  const rebuildAsNeeded = asNeeded; // alias for `build --as-needed`\n  log.info(`Building web extension from ${sourceDir}`);\n\n  const createPackage = () => packageCreator({\n    manifestData,\n    sourceDir,\n    fileFilter,\n    artifactsDir,\n    overwriteDest,\n    showReadyMessage,\n  });\n\n  await prepareArtifactsDir(artifactsDir);\n  const result = await createPackage();\n\n  if (rebuildAsNeeded) {\n    log.info('Rebuilding when files change...');\n    onSourceChange({\n      sourceDir,\n      artifactsDir,\n      onChange: () => {\n        return createPackage().catch((error) => {\n          log.error(error.stack);\n          throw error;\n        });\n      },\n      shouldWatchFile: (...args) => fileFilter.wantFile(...args),\n    });\n  }\n\n  return result;\n}\n","/* @flow */\nimport defaultNotifier from 'node-notifier';\n\nimport {createLogger} from './logger';\nimport type {Logger} from './logger';\n\nconst defaultLog = createLogger(__filename);\n\nexport type DesktopNotificationsParams = {|\n  title: string,\n  message: string,\n  icon?: string,\n|};\n\nexport type DesktopNotificationsOptions = {|\n  notifier?: typeof defaultNotifier,\n  log?: Logger,\n|};\n\nexport function showDesktopNotification(\n  {\n    title, message, icon,\n  }: DesktopNotificationsParams,\n  {\n    notifier = defaultNotifier,\n    log = defaultLog,\n  }: DesktopNotificationsOptions = {}\n): Promise<void> {\n\n  return new Promise((resolve, reject) => {\n    notifier.notify({title, message, icon}, (err, res) => {\n      if (err) {\n        log.debug(`Desktop notifier error: ${err.message},` +\n                 ` response: ${res}`);\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n","module.exports = require(\"camelcase\");","/* @flow */\n\nimport readline from 'readline';\n\nimport type Watchpack from 'watchpack';\n\nimport type {\n  IExtensionRunner, // eslint-disable-line import/named\n  ExtensionRunnerReloadResult,\n} from './base';\nimport {WebExtError} from '../errors';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport type {FirefoxAndroidExtensionRunnerParams} from './firefox-android';\nimport type {FirefoxDesktopExtensionRunnerParams} from './firefox-desktop';\nimport {createLogger} from '../util/logger';\nimport type {FileFilterCreatorFn} from '../util/file-filter';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n} from '../util/file-filter';\nimport {\n  isTTY, setRawMode,\n} from '../util/stdin';\nimport defaultSourceWatcher from '../watcher';\nimport type {OnSourceChangeFn} from '../watcher';\n\n\nconst log = createLogger(__filename);\n\nexport type ExtensionRunnerConfig = {|\n  target: 'firefox-desktop',\n  params: FirefoxDesktopExtensionRunnerParams,\n|} | {|\n  target: 'firefox-android',\n  params: FirefoxAndroidExtensionRunnerParams,\n|};\n\nexport type MultiExtensionRunnerParams = {|\n  runners: Array<IExtensionRunner>,\n  desktopNotifications: typeof defaultDesktopNotifications,\n|};\n\nexport async function createExtensionRunner(config: ExtensionRunnerConfig) {\n  switch (config.target) {\n    case 'firefox-desktop': {\n      // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n      const {FirefoxDesktopExtensionRunner} = require('./firefox-desktop');\n      return new FirefoxDesktopExtensionRunner(config.params);\n    }\n    case 'firefox-android': {\n      // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n      const {FirefoxAndroidExtensionRunner} = require('./firefox-android');\n      return new FirefoxAndroidExtensionRunner(config.params);\n    }\n    default:\n      throw new WebExtError(`Unknown target: \"${config.target}\"`);\n  }\n}\n\n/**\n * Implements an IExtensionRunner which allow the caller to\n * manage multiple extension runners at the same time (e.g. by running\n * a Firefox Desktop instance alongside to a Firefox for Android instance).\n */\nexport class MultiExtensionRunner {\n  extensionRunners: Array<IExtensionRunner>;\n  desktopNotifications: typeof defaultDesktopNotifications;\n\n  constructor(params: MultiExtensionRunnerParams) {\n    this.extensionRunners = params.runners;\n    this.desktopNotifications = params.desktopNotifications;\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Multi Extension Runner';\n  }\n\n  /**\n   * Call the `run` method on all the managed extension runners,\n   * and awaits that all the runners has been successfully started.\n   */\n  async run(): Promise<void> {\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      promises.push(runner.run());\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * Reloads all the extensions on all the managed extension runners,\n   * collect any reload error, and resolves to an array composed by\n   * a ExtensionRunnerReloadResult object per managed runner.\n   *\n   * Any detected reload error is also logged on the terminal and shows as a\n   * desktop notification.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    log.debug('Reloading all reloadable add-ons');\n\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      const reloadPromise = runner.reloadAllExtensions().then(\n        () => {\n          return {runnerName: runner.getName()};\n        },\n        (error) => {\n          return {\n            runnerName: runner.getName(),\n            reloadError: error,\n          };\n        }\n      );\n\n      promises.push(reloadPromise);\n    }\n\n    return await Promise.all(promises).then((results) => {\n      this.handleReloadResults(results);\n      return results;\n    });\n  }\n\n  /**\n   * Reloads a single extension on all the managed extension runners,\n   * collect any reload error and resolves to an array composed by\n   * a ExtensionRunnerReloadResult object per managed runner.\n   *\n   * Any detected reload error is also logged on the terminal and shows as a\n   * desktop notification.\n   */\n  async reloadExtensionBySourceDir(\n    sourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    log.debug(`Reloading add-on at ${sourceDir}`);\n\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      const reloadPromise = runner.reloadExtensionBySourceDir(sourceDir).then(\n        () => {\n          return {runnerName: runner.getName(), sourceDir};\n        },\n        (error) => {\n          return {\n            runnerName: runner.getName(),\n            reloadError: error,\n            sourceDir,\n          };\n        }\n      );\n\n      promises.push(reloadPromise);\n    }\n\n    // $FLOW_FIXME: When upgrading to Flow 0.61.0, it could not follow the type of sourceDir in the array of promises.\n    return await Promise.all(promises).then((results) => {\n      this.handleReloadResults(results);\n      return results;\n    });\n  }\n\n  /**\n   * Register a callback to be called when all the managed runners has been exited.\n   */\n  registerCleanup(cleanupCallback: Function): void {\n    const promises = [];\n\n    // Create a promise for every extension runner managed by this instance,\n    // the promise will be resolved when the particular runner calls its\n    // registered cleanup callbacks.\n    for (const runner of this.extensionRunners) {\n      promises.push(new Promise((resolve) => {\n        runner.registerCleanup(resolve);\n      }));\n    }\n\n    // Wait for all the created promises to be resolved or rejected\n    // (once each one of the runners has cleaned up) and then call\n    // the cleanup callback registered to this runner.\n    Promise.all(promises).then(cleanupCallback, cleanupCallback);\n  }\n\n  /**\n   * Exits all the managed runner has been exited.\n   */\n  async exit(): Promise<void> {\n    const promises = [];\n    for (const runner of this.extensionRunners) {\n      promises.push(runner.exit());\n    }\n\n    await Promise.all(promises);\n  }\n\n  // Private helper methods.\n\n  handleReloadResults(results: Array<ExtensionRunnerReloadResult>): void {\n    for (const {runnerName, reloadError, sourceDir} of results) {\n      if (reloadError instanceof Error) {\n        let message = 'Error occurred while reloading';\n        if (sourceDir) {\n          message += ` \"${sourceDir}\" `;\n        }\n\n        message += `on \"${runnerName}\" - ${reloadError.message}`;\n\n        log.error(`\\n${message}`);\n        log.debug(reloadError.stack);\n\n        this.desktopNotifications({\n          title: 'web-ext run: extension reload error',\n          message,\n        });\n      }\n    }\n  }\n}\n\n// defaultWatcherCreator types and implementation.\n\nexport type WatcherCreatorParams = {|\n  reloadExtension: (string) => void,\n  sourceDir: string,\n  artifactsDir: string,\n  onSourceChange?: OnSourceChangeFn,\n  ignoreFiles?: Array<string>,\n  createFileFilter?: FileFilterCreatorFn,\n|};\n\nexport type WatcherCreatorFn = (params: WatcherCreatorParams) => Watchpack;\n\nexport function defaultWatcherCreator(\n  {\n    reloadExtension, sourceDir, artifactsDir, ignoreFiles,\n    onSourceChange = defaultSourceWatcher,\n    createFileFilter = defaultFileFilterCreator,\n  }: WatcherCreatorParams\n): Watchpack {\n  const fileFilter = createFileFilter(\n    {sourceDir, artifactsDir, ignoreFiles}\n  );\n  return onSourceChange({\n    sourceDir,\n    artifactsDir,\n    onChange: () => reloadExtension(sourceDir),\n    shouldWatchFile: (file) => fileFilter.wantFile(file),\n  });\n}\n\n\n// defaultReloadStrategy types and implementation.\n\nexport type ReloadStrategyParams = {|\n  extensionRunner: IExtensionRunner,\n  sourceDir: string,\n  artifactsDir: string,\n  ignoreFiles?: Array<string>,\n  noInput?: boolean,\n|};\n\nexport type ReloadStrategyOptions = {|\n  createWatcher?: WatcherCreatorFn,\n  stdin?: stream$Readable,\n  kill?: typeof process.kill,\n|};\n\nexport function defaultReloadStrategy(\n  {\n    artifactsDir,\n    extensionRunner,\n    ignoreFiles,\n    noInput = false,\n    sourceDir,\n  }: ReloadStrategyParams,\n  {\n    createWatcher = defaultWatcherCreator,\n    stdin = process.stdin,\n    kill = process.kill,\n  }: ReloadStrategyOptions = {}\n): void {\n  const allowInput = !noInput;\n  if (!allowInput) {\n    log.debug('Input has been disabled because of noInput==true');\n  }\n\n  const watcher: Watchpack = createWatcher({\n    reloadExtension: (watchedSourceDir) => {\n      extensionRunner.reloadExtensionBySourceDir(watchedSourceDir);\n    },\n    sourceDir,\n    artifactsDir,\n    ignoreFiles,\n  });\n\n  extensionRunner.registerCleanup(() => {\n    watcher.close();\n    if (allowInput) {\n      stdin.pause();\n    }\n  });\n\n  if (allowInput && isTTY(stdin)) {\n    readline.emitKeypressEvents(stdin);\n    setRawMode(stdin, true);\n\n    const keypressUsageInfo = 'Press R to reload (and Ctrl-C to quit)';\n\n    // NOTE: this `Promise.resolve().then(...)` is basically used to spawn a \"co-routine\"\n    // that is executed before the callback attached to the Promise returned by this function\n    // (and it allows the `run` function to not be stuck in the while loop).\n    Promise.resolve().then(async function() {\n      log.info(keypressUsageInfo);\n\n      let userExit = false;\n\n      while (!userExit) {\n        const keyPressed = await new Promise((resolve) => {\n          stdin.once('keypress', (str, key) => resolve(key));\n        });\n\n        if (keyPressed.ctrl && keyPressed.name === 'c') {\n          userExit = true;\n        } else if (keyPressed.name === 'z') {\n          // Prepare to suspend.\n\n          // NOTE: Switch the raw mode off before suspending (needed to make the keypress event\n          // to work correctly when the nodejs process is resumed).\n          setRawMode(stdin, false);\n\n          log.info('\\nweb-ext has been suspended on user request');\n          kill(process.pid, 'SIGTSTP');\n\n          // Prepare to resume.\n\n          log.info(`\\nweb-ext has been resumed. ${keypressUsageInfo}`);\n\n          // Switch the raw mode on on resume.\n          setRawMode(stdin, true);\n        } else if (keyPressed.name === 'r') {\n          log.debug('Reloading installed extensions on user request');\n          extensionRunner.reloadAllExtensions();\n        }\n      }\n\n      log.info('\\nExiting web-ext on user request');\n      extensionRunner.exit();\n    });\n  }\n}\n","/* @flow */\nimport nodeFs from 'fs';\nimport path from 'path';\n\nimport {default as defaultFxRunner} from 'fx-runner';\nimport FirefoxProfile, {copyFromUserProfile as defaultUserProfileCopier}\n  from 'firefox-profile';\nimport {fs} from 'mz';\nimport promisify from 'es6-promisify';\nimport eventToPromise from 'event-to-promise';\n\nimport isDirectory from '../util/is-directory';\nimport {isErrorWithCode, UsageError, WebExtError} from '../errors';\nimport {getPrefs as defaultPrefGetter} from './preferences';\nimport {getManifestId} from '../util/manifest';\nimport {createLogger} from '../util/logger';\nimport {connect as defaultFirefoxConnector, REMOTE_PORT} from './remote';\n// Import flow types\nimport type {FirefoxConnectorFn} from './remote';\nimport type {\n  PreferencesAppName,\n  PreferencesGetterFn,\n  FirefoxPreferences,\n} from './preferences';\nimport type {ExtensionManifest} from '../util/manifest';\n\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncFsStat = fs.stat.bind(fs);\n\nexport const defaultFirefoxEnv = {\n  XPCOM_DEBUG_BREAK: 'stack',\n  NS_TRACE_MALLOC_DISABLE_STACKS: '1',\n};\n\n// defaultRemotePortFinder types and implementation.\n\nexport type RemotePortFinderParams = {|\n  portToTry?: number,\n  retriesLeft?: number,\n  connectToFirefox?: FirefoxConnectorFn,\n|};\n\nexport type RemotePortFinderFn =\n  (params?: RemotePortFinderParams) => Promise<number>;\n\nexport async function defaultRemotePortFinder(\n  {\n    portToTry = REMOTE_PORT,\n    retriesLeft = 10,\n    connectToFirefox = defaultFirefoxConnector,\n  }: RemotePortFinderParams = {}\n): Promise<number> {\n  log.debug(`Checking if remote Firefox port ${portToTry} is available`);\n\n  let client;\n\n  while (retriesLeft >= 0) {\n    try {\n      client = await connectToFirefox(portToTry);\n      log.debug(`Remote Firefox port ${portToTry} is in use ` +\n                `(retries remaining: ${retriesLeft})`);\n    } catch (error) {\n      if (isErrorWithCode('ECONNREFUSED', error)) {\n        // The connection was refused so this port is good to use.\n        return portToTry;\n      }\n\n      throw error;\n    }\n\n    client.disconnect();\n    portToTry++;\n    retriesLeft--;\n  }\n\n  throw new WebExtError('Too many retries on port search');\n}\n\n\n// Declare the needed 'fx-runner' module flow types.\n\nexport type FirefoxRunnerParams = {|\n  binary: ?string,\n  profile?: string,\n  'new-instance'?: boolean,\n  'no-remote'?: boolean,\n  'foreground'?: boolean,\n  'listen': number,\n  'binary-args'?: Array<string> | string,\n  'env'?: {\n    [key: string]: string\n  },\n  'verbose'?: boolean,\n|};\n\nexport interface FirefoxProcess extends events$EventEmitter {\n  stderr: events$EventEmitter;\n  stdout: events$EventEmitter;\n  kill: Function;\n}\n\nexport type FirefoxRunnerResults = {|\n  process: FirefoxProcess,\n  binary: string,\n  args: Array<string>,\n|}\n\nexport type FirefoxRunnerFn =\n  (params: FirefoxRunnerParams) => Promise<FirefoxRunnerResults>;\n\n\nexport type FirefoxInfo = {|\n  firefox: FirefoxProcess,\n  debuggerPort: number,\n|}\n\n// Run command types and implementaion.\n\nexport type FirefoxRunOptions = {|\n  fxRunner?: FirefoxRunnerFn,\n  findRemotePort?: RemotePortFinderFn,\n  firefoxBinary?: string,\n  binaryArgs?: Array<string>,\n  args?: Array<any>,\n|};\n\n/*\n * Runs Firefox with the given profile object and resolves a promise on exit.\n */\nexport async function run(\n  profile: FirefoxProfile,\n  {\n    fxRunner = defaultFxRunner,\n    findRemotePort = defaultRemotePortFinder,\n    firefoxBinary, binaryArgs,\n  }: FirefoxRunOptions = {}\n): Promise<FirefoxInfo> {\n\n  log.debug(`Running Firefox with profile at ${profile.path()}`);\n\n  const remotePort = await findRemotePort();\n\n  const results = await fxRunner({\n    // if this is falsey, fxRunner tries to find the default one.\n    'binary': firefoxBinary,\n    'binary-args': binaryArgs,\n    // This ensures a new instance of Firefox is created. It has nothing\n    // to do with the devtools remote debugger.\n    'no-remote': true,\n    'listen': remotePort,\n    'foreground': true,\n    'profile': profile.path(),\n    'env': {\n      ...process.env,\n      ...defaultFirefoxEnv,\n    },\n    'verbose': true,\n  });\n\n  const firefox = results.process;\n\n  log.debug(`Executing Firefox binary: ${results.binary}`);\n  log.debug(`Firefox args: ${results.args.join(' ')}`);\n\n  firefox.on('error', (error) => {\n    // TODO: show a nice error when it can't find Firefox.\n    // if (/No such file/.test(err) || err.code === 'ENOENT') {\n    log.error(`Firefox error: ${error}`);\n    throw error;\n  });\n\n  log.info(\n    'Use --verbose or open Tools > Web Developer > Browser Console ' +\n    'to see logging');\n\n  firefox.stderr.on('data', (data) => {\n    log.debug(`Firefox stderr: ${data.toString().trim()}`);\n  });\n\n  firefox.stdout.on('data', (data) => {\n    log.debug(`Firefox stdout: ${data.toString().trim()}`);\n  });\n\n  firefox.on('close', () => {\n    log.debug('Firefox closed');\n  });\n\n  return { firefox, debuggerPort: remotePort };\n}\n\n\n// isDefaultProfile types and implementation.\n\nconst DEFAULT_PROFILES_NAMES = [\n  'default',\n  'dev-edition-default',\n];\n\nexport type IsDefaultProfileFn = (\n  profilePathOrName: string,\n  ProfileFinder?: typeof FirefoxProfile.Finder,\n  fsStat?: typeof fs.stat,\n) => Promise<boolean>;\n\n/*\n * Tests if a profile is a default Firefox profile (both as a profile name or\n * profile path).\n *\n * Returns a promise that resolves to true if the profile is one of default Firefox profile.\n */\nexport async function isDefaultProfile(\n  profilePathOrName: string,\n  ProfileFinder?: typeof FirefoxProfile.Finder = FirefoxProfile.Finder,\n  fsStat?: typeof fs.stat = fs.stat,\n): Promise<boolean> {\n  if (DEFAULT_PROFILES_NAMES.includes(profilePathOrName)) {\n    return true;\n  }\n\n  const baseProfileDir = ProfileFinder.locateUserDirectory();\n  const profilesIniPath = path.join(baseProfileDir, 'profiles.ini');\n  try {\n    await fsStat(profilesIniPath);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`profiles.ini not found: ${error}`);\n\n      // No profiles exist yet, default to false (the default profile name contains a\n      // random generated component).\n      return false;\n    }\n\n    // Re-throw any unexpected exception.\n    throw error;\n  }\n\n  // Check for profile dir path.\n  const finder = new ProfileFinder(baseProfileDir);\n  const readProfiles = promisify(finder.readProfiles, finder);\n\n  await readProfiles();\n\n  const normalizedProfileDirPath = path.normalize(\n    path.join(path.resolve(profilePathOrName), path.sep)\n  );\n\n  for (const profile of finder.profiles) {\n    // Check if the profile dir path or name is one of the default profiles\n    // defined in the profiles.ini file.\n    if (DEFAULT_PROFILES_NAMES.includes(profile.Name) ||\n        profile.Default === '1') {\n      let profileFullPath;\n\n      // Check for profile name.\n      if (profile.Name === profilePathOrName) {\n        return true;\n      }\n\n      // Check for profile path.\n      if (profile.IsRelative === '1') {\n        profileFullPath = path.join(baseProfileDir, profile.Path, path.sep);\n      } else {\n        profileFullPath = path.join(profile.Path, path.sep);\n      }\n\n      if (path.normalize(profileFullPath) === normalizedProfileDirPath) {\n        return true;\n      }\n    }\n  }\n\n  // Profile directory not found.\n  return false;\n}\n\n// configureProfile types and implementation.\n\nexport type ConfigureProfileOptions = {|\n  app?: PreferencesAppName,\n  getPrefs?: PreferencesGetterFn,\n  customPrefs?: FirefoxPreferences,\n|};\n\nexport type ConfigureProfileFn = (\n  profile: FirefoxProfile,\n  options?: ConfigureProfileOptions\n) => Promise<FirefoxProfile>;\n\n/*\n * Configures a profile with common preferences that are required to\n * activate extension development.\n *\n * Returns a promise that resolves with the original profile object.\n */\nexport function configureProfile(\n  profile: FirefoxProfile,\n  {\n    app = 'firefox',\n    getPrefs = defaultPrefGetter,\n    customPrefs = {},\n  }: ConfigureProfileOptions = {},\n): Promise<FirefoxProfile> {\n  // Set default preferences. Some of these are required for the add-on to\n  // operate, such as disabling signatures.\n  const prefs = getPrefs(app);\n  Object.keys(prefs).forEach((pref) => {\n    profile.setPreference(pref, prefs[pref]);\n  });\n  if (Object.keys(customPrefs).length > 0) {\n    const customPrefsStr = JSON.stringify(customPrefs, null, 2);\n    log.info(`Setting custom Firefox preferences: ${customPrefsStr}`);\n    Object.keys(customPrefs).forEach((custom) => {\n      profile.setPreference(custom, customPrefs[custom]);\n    });\n  }\n  profile.updatePreferences();\n  return Promise.resolve(profile);\n}\n\nexport type getProfileFn = (profileName: string) => Promise<string | void>;\n\nexport type CreateProfileFinderParams = {|\n  userDirectoryPath?: string,\n  FxProfile?: typeof FirefoxProfile\n|}\n\nexport function defaultCreateProfileFinder(\n  {\n    userDirectoryPath,\n    FxProfile = FirefoxProfile,\n  }: CreateProfileFinderParams = {}\n): getProfileFn {\n  const finder = new FxProfile.Finder(userDirectoryPath);\n  const readProfiles = promisify(finder.readProfiles, finder);\n  const getPath = promisify(finder.getPath, finder);\n  return async (profileName: string): Promise<string | void> => {\n    try {\n      await readProfiles();\n      const hasProfileName = finder.profiles.filter(\n        (profileDef) => profileDef.Name === profileName).length !== 0;\n      if (hasProfileName) {\n        return await getPath(profileName);\n      }\n    } catch (error) {\n      if (!isErrorWithCode('ENOENT', error)) {\n        throw error;\n      }\n      log.warn('Unable to find Firefox profiles.ini');\n    }\n  };\n}\n\n// useProfile types and implementation.\n\nexport type UseProfileParams = {\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  isFirefoxDefaultProfile?: IsDefaultProfileFn,\n  customPrefs?: FirefoxPreferences,\n  createProfileFinder?: typeof defaultCreateProfileFinder,\n};\n\n// Use the target path as a Firefox profile without cloning it\n\nexport async function useProfile(\n  profilePath: string,\n  {\n    app,\n    configureThisProfile = configureProfile,\n    isFirefoxDefaultProfile = isDefaultProfile,\n    customPrefs = {},\n    createProfileFinder = defaultCreateProfileFinder,\n  }: UseProfileParams = {},\n): Promise<FirefoxProfile> {\n  const isForbiddenProfile = await isFirefoxDefaultProfile(profilePath);\n  if (isForbiddenProfile) {\n    throw new UsageError(\n      'Cannot use --keep-profile-changes on a default profile' +\n      ` (\"${profilePath}\")` +\n      ' because web-ext will make it insecure and unsuitable for daily use.' +\n      '\\nSee https://github.com/mozilla/web-ext/issues/1005'\n    );\n  }\n\n  let destinationDirectory;\n  const getProfilePath = createProfileFinder();\n\n  const profileIsDirPath = await isDirectory(profilePath);\n  if (profileIsDirPath) {\n    log.debug(`Using profile directory \"${profilePath}\"`);\n    destinationDirectory = profilePath;\n  } else {\n    log.debug(`Assuming ${profilePath} is a named profile`);\n    destinationDirectory = await getProfilePath(profilePath);\n    if (!destinationDirectory) {\n      throw new UsageError(\n        `The request \"${profilePath}\" profile name ` +\n        'cannot be resolved to a profile path'\n      );\n    }\n  }\n\n  const profile = new FirefoxProfile({destinationDirectory});\n  return await configureThisProfile(profile, {app, customPrefs});\n}\n\n\n// createProfile types and implementation.\n\nexport type CreateProfileParams = {\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  customPrefs?: FirefoxPreferences,\n};\n\n/*\n * Creates a new temporary profile and resolves with the profile object.\n *\n * The profile will be deleted when the system process exits.\n */\nexport async function createProfile(\n  {\n    app,\n    configureThisProfile = configureProfile,\n    customPrefs = {},\n  }: CreateProfileParams = {},\n): Promise<FirefoxProfile> {\n  const profile = new FirefoxProfile();\n  return await configureThisProfile(profile, {app, customPrefs});\n}\n\n\n// copyProfile types and implementation.\n\nexport type CopyProfileOptions = {|\n  app?: PreferencesAppName,\n  configureThisProfile?: ConfigureProfileFn,\n  copyFromUserProfile?: Function,\n  customPrefs?: FirefoxPreferences,\n|};\n\n/*\n * Copies an existing Firefox profile and creates a new temporary profile.\n * The new profile will be configured with some preferences required to\n * activate extension development.\n *\n * It resolves with the new profile object.\n *\n * The temporary profile will be deleted when the system process exits.\n *\n * The existing profile can be specified as a directory path or a name of\n * one that exists in the current user's Firefox directory.\n */\nexport async function copyProfile(\n  profileDirectory: string,\n  {\n    app,\n    configureThisProfile = configureProfile,\n    copyFromUserProfile = defaultUserProfileCopier,\n    customPrefs = {},\n  }: CopyProfileOptions = {},\n): Promise<FirefoxProfile> {\n\n  const copy = promisify(FirefoxProfile.copy);\n  const copyByName = promisify(copyFromUserProfile);\n\n  try {\n    const dirExists = await isDirectory(profileDirectory);\n\n    let profile;\n\n    if (dirExists) {\n      log.debug(`Copying profile directory from \"${profileDirectory}\"`);\n      profile = await copy({profileDirectory});\n    } else {\n      log.debug(`Assuming ${profileDirectory} is a named profile`);\n      profile = await copyByName({name: profileDirectory});\n    }\n\n    return configureThisProfile(profile, {app, customPrefs});\n  } catch (error) {\n    throw new WebExtError(\n      `Could not copy Firefox profile from ${profileDirectory}: ${error}`);\n  }\n}\n\n\n// installExtension types and implementation.\n\nexport type InstallExtensionParams = {|\n  asProxy?: boolean,\n  manifestData: ExtensionManifest,\n  profile: FirefoxProfile,\n  extensionPath: string,\n  asyncFsStat?: typeof defaultAsyncFsStat,\n|};\n\n/*\n * Installs an extension into the given Firefox profile object.\n * Resolves when complete.\n *\n * The extension is copied into a special location and you need to turn\n * on some preferences to allow this. See extensions.autoDisableScopes in\n * ./preferences.js.\n *\n * When asProxy is true, a special proxy file will be installed. This is a\n * text file that contains the path to the extension source.\n */\nexport async function installExtension(\n  {\n    asProxy = false,\n    manifestData,\n    profile,\n    extensionPath,\n    asyncFsStat = defaultAsyncFsStat,\n  }: InstallExtensionParams): Promise<any> {\n  // This more or less follows\n  // https://github.com/saadtazi/firefox-profile-js/blob/master/lib/firefox_profile.js#L531\n  // (which is broken for web extensions).\n  // TODO: maybe uplift a patch that supports web extensions instead?\n\n  if (!profile.extensionsDir) {\n    throw new WebExtError('profile.extensionsDir was unexpectedly empty');\n  }\n\n  try {\n    await asyncFsStat(profile.extensionsDir);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`Creating extensions directory: ${profile.extensionsDir}`);\n      await fs.mkdir(profile.extensionsDir);\n    } else {\n      throw error;\n    }\n  }\n\n  const id = getManifestId(manifestData);\n  if (!id) {\n    throw new UsageError(\n      'An explicit extension ID is required when installing to ' +\n      'a profile (applications.gecko.id not found in manifest.json)');\n  }\n\n  if (asProxy) {\n    log.debug(`Installing as an extension proxy; source: ${extensionPath}`);\n\n    const isDir = await isDirectory(extensionPath);\n    if (!isDir) {\n      throw new WebExtError(\n        'proxy install: extensionPath must be the extension source ' +\n        `directory; got: ${extensionPath}`);\n    }\n\n    // Write a special extension proxy file containing the source\n    // directory. See:\n    // https://developer.mozilla.org/en-US/Add-ons/Setting_up_extension_development_environment#Firefox_extension_proxy_file\n    const destPath = path.join(profile.extensionsDir, `${id}`);\n    const writeStream = nodeFs.createWriteStream(destPath);\n    writeStream.write(extensionPath);\n    writeStream.end();\n    return await eventToPromise(writeStream, 'close');\n  } else {\n    // Write the XPI file to the profile.\n    const readStream = nodeFs.createReadStream(extensionPath);\n    const destPath = path.join(profile.extensionsDir, `${id}.xpi`);\n    const writeStream = nodeFs.createWriteStream(destPath);\n\n    log.debug(`Installing extension from ${extensionPath} to ${destPath}`);\n    readStream.pipe(writeStream);\n\n    return await Promise.all([\n      eventToPromise(readStream, 'close'),\n      eventToPromise(writeStream, 'close'),\n    ]);\n  }\n}\n","module.exports = require(\"os\");","/* @flow */\n\nimport type {\n  BuildCmdParams, BuildCmdOptions, ExtensionBuildResult,\n} from './build';\nimport type {LintCmdParams, LintCmdOptions} from './lint';\nimport type {CmdRunParams, CmdRunOptions} from './run';\nimport type {MultiExtensionRunner} from '../extension-runners';\nimport type {SignParams, SignOptions, SignResult} from './sign';\nimport type {DocsParams, DocsOptions} from './docs';\n\n// This module exports entry points for all supported commands. For performance\n// reasons (faster start-up), the implementations are not statically imported\n// at the top of the file, but lazily loaded in the (exported) functions.\n// The latter would slow down start-up by several seconds, as seen in #1302 .\n\nasync function build(\n  params: BuildCmdParams, options: BuildCmdOptions\n): Promise<ExtensionBuildResult> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./build');\n  return runCommand(params, options);\n}\n\nasync function lint(\n  params: LintCmdParams, options: LintCmdOptions\n): Promise<void> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./lint');\n  return runCommand(params, options);\n}\n\nasync function run(\n  params: CmdRunParams, options: CmdRunOptions\n): Promise<MultiExtensionRunner> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./run');\n  return runCommand(params, options);\n}\n\nasync function sign(\n  params: SignParams, options: SignOptions\n): Promise<SignResult> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./sign');\n  return runCommand(params, options);\n}\n\nasync function docs(\n  params: DocsParams, options: DocsOptions\n): Promise<void> {\n  // TODO: use async import instead of require - https://github.com/mozilla/web-ext/issues/1306\n  const {default: runCommand} = require('./docs');\n  return runCommand(params, options);\n}\n\nexport default {build, lint, run, sign, docs};\n","module.exports = require(\"parse-json\");","module.exports = require(\"strip-json-comments\");","/* @flow */\nimport Watchpack from 'watchpack';\nimport debounce from 'debounce';\n\nimport {createLogger} from './util/logger';\n\n\nconst log = createLogger(__filename);\n\n\n// onSourceChange types and implementation\n\nexport type ShouldWatchFn = (filePath: string) => boolean;\n\nexport type OnChangeFn = () => any;\n\nexport type OnSourceChangeParams = {|\n  sourceDir: string,\n  artifactsDir: string,\n  onChange: OnChangeFn,\n  shouldWatchFile: ShouldWatchFn,\n|};\n\n// NOTE: this fix an issue with flow and default exports (which currently\n// lose their type signatures) by explicitly declare the default export\n// signature. Reference: https://github.com/facebook/flow/issues/449\n// eslint-disable-next-line no-shadow\ndeclare function exports(params: OnSourceChangeParams): Watchpack;\n\nexport type OnSourceChangeFn = (params: OnSourceChangeParams) => Watchpack;\n\nexport default function onSourceChange(\n  {sourceDir, artifactsDir, onChange, shouldWatchFile}: OnSourceChangeParams\n): Watchpack {\n  // TODO: For network disks, we would need to add {poll: true}.\n  const watcher = new Watchpack();\n\n  const executeImmediately = true;\n  onChange = debounce(onChange, 1000, executeImmediately);\n\n  watcher.on('change', (filePath) => {\n    proxyFileChanges({artifactsDir, onChange, filePath, shouldWatchFile});\n  });\n\n  log.debug(`Watching for file changes in ${sourceDir}`);\n  watcher.watch([], [sourceDir], Date.now());\n\n  // TODO: support interrupting the watcher on Windows.\n  // https://github.com/mozilla/web-ext/issues/225\n  process.on('SIGINT', () => watcher.close());\n  return watcher;\n}\n\n\n// proxyFileChanges types and implementation.\n\nexport type ProxyFileChangesParams = {|\n  artifactsDir: string,\n  onChange: OnChangeFn,\n  filePath: string,\n  shouldWatchFile: ShouldWatchFn,\n|};\n\nexport function proxyFileChanges(\n  {artifactsDir, onChange, filePath, shouldWatchFile}: ProxyFileChangesParams\n): void {\n  if (filePath.indexOf(artifactsDir) === 0 || !shouldWatchFile(filePath)) {\n    log.debug(`Ignoring change to: ${filePath}`);\n  } else {\n    log.debug(`Changed: ${filePath}`);\n    log.debug(`Last change detection: ${(new Date()).toTimeString()}`);\n    onChange();\n  }\n}\n","/* @flow */\nimport {fs} from 'mz';\nimport mkdirp from 'mkdirp';\nimport promisify from 'es6-promisify';\n\nimport {UsageError, isErrorWithCode} from '../errors';\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncMkdirp = promisify(mkdirp);\nconst defaultAsyncFsAccess = fs.access.bind(fs);\n\ntype PrepareArtifactsDirOptions = {\n  asyncMkdirp?: typeof defaultAsyncMkdirp,\n  asyncFsAccess?: typeof defaultAsyncFsAccess,\n}\n\nexport async function prepareArtifactsDir(\n  artifactsDir: string,\n  {\n    asyncMkdirp = defaultAsyncMkdirp,\n    asyncFsAccess = defaultAsyncFsAccess,\n  }: PrepareArtifactsDirOptions = {},\n): Promise<string> {\n  try {\n    const stats = await fs.stat(artifactsDir);\n    if (!stats.isDirectory()) {\n      throw new UsageError(\n        `--artifacts-dir=\"${artifactsDir}\" exists but it is not a directory.`);\n    }\n    // If the artifactsDir already exists, check that we have the write permissions on it.\n    try {\n      await asyncFsAccess(artifactsDir, fs.W_OK);\n    } catch (accessErr) {\n      if (isErrorWithCode('EACCES', accessErr)) {\n        throw new UsageError(\n          `--artifacts-dir=\"${artifactsDir}\" exists but the user lacks ` +\n          'permissions on it.');\n      } else {\n        throw accessErr;\n      }\n    }\n  } catch (error) {\n    if (isErrorWithCode('EACCES', error)) {\n      // Handle errors when the artifactsDir cannot be accessed.\n      throw new UsageError(\n        `Cannot access --artifacts-dir=\"${artifactsDir}\" because the user ` +\n        `lacks permissions: ${error}`);\n    } else if (isErrorWithCode('ENOENT', error)) {\n      // Create the artifact dir if it doesn't exist yet.\n      try {\n        log.debug(`Creating artifacts directory: ${artifactsDir}`);\n        await asyncMkdirp(artifactsDir);\n      } catch (mkdirErr) {\n        if (isErrorWithCode('EACCES', mkdirErr)) {\n          // Handle errors when the artifactsDir cannot be created for lack of permissions.\n          throw new UsageError(\n            `Cannot create --artifacts-dir=\"${artifactsDir}\" because the ` +\n            `user lacks permissions: ${mkdirErr}`);\n        } else {\n          throw mkdirErr;\n        }\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  return artifactsDir;\n}\n","/* @flow */\nimport {WebExtError, UsageError} from '../errors';\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\nexport const nonOverridablePreferences = [\n  'devtools.debugger.remote-enabled', 'devtools.debugger.prompt-connection',\n  'xpinstall.signatures.required',\n];\n\n// Flow Types\n\nexport type FirefoxPreferences = {\n  [key: string]: boolean | string | number,\n};\n\nexport type PreferencesAppName = 'firefox' | 'fennec';\n\n\n// Preferences Maps\n\nconst prefsCommon: FirefoxPreferences = {\n  // Allow debug output via dump to be printed to the system console\n  'browser.dom.window.dump.enabled': true,\n\n  // Allow remote connections to the debugger.\n  'devtools.debugger.remote-enabled': true,\n  // Disable the prompt for allowing connections.\n  'devtools.debugger.prompt-connection': false,\n\n  // Turn off platform logging because it is a lot of info.\n  'extensions.logging.enabled': false,\n\n  // Disable extension updates and notifications.\n  'extensions.checkCompatibility.nightly': false,\n  'extensions.update.enabled': false,\n  'extensions.update.notifyUser': false,\n\n  // From:\n  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l372\n  // Only load extensions from the application and user profile.\n  // AddonManager.SCOPE_PROFILE + AddonManager.SCOPE_APPLICATION\n  'extensions.enabledScopes': 5,\n  // Disable metadata caching for installed add-ons by default.\n  'extensions.getAddons.cache.enabled': false,\n  // Disable intalling any distribution add-ons.\n  'extensions.installDistroAddons': false,\n  // Allow installing extensions dropped into the profile folder.\n  'extensions.autoDisableScopes': 10,\n\n  // Disable app update.\n  'app.update.enabled': false,\n\n  // Allow unsigned add-ons.\n  'xpinstall.signatures.required': false,\n};\n\n// Prefs specific to Firefox for Android.\nconst prefsFennec: FirefoxPreferences = {\n  'browser.console.showInPanel': true,\n  'browser.firstrun.show.uidiscovery': false,\n  'devtools.remote.usb.enabled': true,\n};\n\n// Prefs specific to Firefox for desktop.\nconst prefsFirefox: FirefoxPreferences = {\n  'browser.startup.homepage': 'about:blank',\n  'startup.homepage_welcome_url': 'about:blank',\n  'startup.homepage_welcome_url.additional': '',\n  'devtools.errorconsole.enabled': true,\n  'devtools.chrome.enabled': true,\n\n  // From:\n  // http://hg.mozilla.org/mozilla-central/file/1dd81c324ac7/build/automation.py.in//l388\n  // Make url-classifier updates so rare that they won't affect tests.\n  'urlclassifier.updateinterval': 172800,\n  // Point the url-classifier to a nonexistent local URL for fast failures.\n  'browser.safebrowsing.provider.0.gethashURL':\n    'http://localhost/safebrowsing-dummy/gethash',\n  'browser.safebrowsing.provider.0.keyURL':\n    'http://localhost/safebrowsing-dummy/newkey',\n  'browser.safebrowsing.provider.0.updateURL':\n    'http://localhost/safebrowsing-dummy/update',\n\n  // Disable self repair/SHIELD\n  'browser.selfsupport.url': 'https://localhost/selfrepair',\n  // Disable Reader Mode UI tour\n  'browser.reader.detectedFirstArticle': true,\n\n  // Set the policy firstURL to an empty string to prevent\n  // the privacy info page to be opened on every \"web-ext run\".\n  // (See #1114 for rationale)\n  'datareporting.policy.firstRunURL': '',\n};\n\nconst prefs = {\n  common: prefsCommon,\n  fennec: prefsFennec,\n  firefox: prefsFirefox,\n};\n\n\n// Module exports\n\nexport type PreferencesGetterFn =\n  (appName: PreferencesAppName) => FirefoxPreferences;\n\nexport function getPrefs(\n  app: PreferencesAppName = 'firefox'\n): FirefoxPreferences {\n  const appPrefs = prefs[app];\n  if (!appPrefs) {\n    throw new WebExtError(`Unsupported application: ${app}`);\n  }\n  return {\n    ...prefsCommon,\n    ...appPrefs,\n  };\n}\n\nexport function coerceCLICustomPreference(\n  cliPrefs: Array<string>\n): FirefoxPreferences {\n  const customPrefs = {};\n\n  for (const pref of cliPrefs) {\n    const prefsAry = pref.split('=');\n\n    if (prefsAry.length < 2) {\n      throw new UsageError(\n        `Incomplete custom preference: \"${pref}\". ` +\n        'Syntax expected: \"prefname=prefvalue\".'\n      );\n    }\n\n    const key = prefsAry[0];\n    let value = prefsAry.slice(1).join('=');\n\n    if (/[^\\w{@}.-]/.test(key)) {\n      throw new UsageError(`Invalid custom preference name: ${key}`);\n    }\n\n    if (value === `${parseInt(value)}`) {\n      value = parseInt(value, 10);\n    } else if (value === 'true' || value === 'false') {\n      value = (value === 'true');\n    }\n\n    if (nonOverridablePreferences.includes(key)) {\n      log.warn(`'${key}' preference cannot be customized.`);\n      continue;\n    }\n    customPrefs[`${key}`] = value;\n  }\n\n  return customPrefs;\n}\n","module.exports = require(\"readline\");","/* @flow */\nimport tmp from 'tmp';\nimport promisify from 'es6-promisify';\n\nimport {createLogger} from './logger';\n\nconst log = createLogger(__filename);\n\nexport type MakePromiseCallback = (tmpDir: TempDir) => any;\n\n\n/*\n * Work with a self-destructing temporary directory in a promise chain.\n *\n * The directory will be destroyed when the promise chain is finished\n * (whether there was an error or not).\n *\n * Usage:\n *\n * withTempDir(\n *   (tmpDir) =>\n *     doSomething(tmpDir.path())\n *     .then(...)\n * );\n *\n */\nexport function withTempDir(makePromise: MakePromiseCallback): Promise<any> {\n  const tmpDir = new TempDir();\n  return tmpDir.create()\n    .then(() => {\n      return makePromise(tmpDir);\n    })\n    .catch(tmpDir.errorHandler())\n    .then(tmpDir.successHandler());\n}\n\n/*\n * Work with a self-destructing temporary directory object.\n *\n * It is safer to use withTempDir() instead but if you know\n * what you're doing you can use it directly like:\n *\n * let tmpDir = new TempDir();\n * tmpDir.create()\n *   .then(() => {\n *     // work with tmpDir.path()\n *   })\n *   .catch(tmpDir.errorHandler())\n *   .then(tmpDir.successHandler());\n *\n */\nexport class TempDir {\n  _path: string | void;\n  _removeTempDir: Function | void;\n\n  constructor() {\n    this._path = undefined;\n    this._removeTempDir = undefined;\n  }\n\n  /*\n   * Returns a promise that is fulfilled when the temp directory has\n   * been created.\n   */\n  create(): Promise<TempDir> {\n    const createTempDir = promisify(tmp.dir, {multiArgs: true});\n    return createTempDir(\n      {\n        prefix: 'tmp-web-ext-',\n        // This allows us to remove a non-empty tmp dir.\n        unsafeCleanup: true,\n      })\n      .then((args) => {\n        const [tmpPath, removeTempDir] = args;\n        this._path = tmpPath;\n        this._removeTempDir = removeTempDir;\n        log.debug(`Created temporary directory: ${this.path()}`);\n        return this;\n      });\n  }\n\n  /*\n   * Get the absolute path of the temp directory.\n   */\n  path(): string {\n    if (!this._path) {\n      throw new Error('You cannot access path() before calling create()');\n    }\n    return this._path;\n  }\n\n  /*\n   * Returns a callback that will catch an error, remove\n   * the temporary directory, and throw the error.\n   *\n   * This is intended for use in a promise like\n   * Promise().catch(tmp.errorHandler())\n   */\n  errorHandler(): Function {\n    return (error) => {\n      this.remove();\n      throw error;\n    };\n  }\n\n  /*\n   * Returns a callback that will remove the temporary direcotry.\n   *\n   * This is intended for use in a promise like\n   * Promise().then(tmp.successHandler())\n   */\n  successHandler(): Function {\n    return (promiseResult) => {\n      this.remove();\n      return promiseResult;\n    };\n  }\n\n  /*\n   * Remove the temp directory.\n   */\n  remove() {\n    if (!this._removeTempDir) {\n      return;\n    }\n    log.debug(`Removing temporary directory: ${this.path()}`);\n    this._removeTempDir && this._removeTempDir();\n  }\n\n}\n","/* @flow */\nimport {fs} from 'mz';\n\nimport {onlyErrorsWithCode} from '../errors';\n\n/*\n * Resolves true if the path is a readable directory.\n *\n * Usage:\n *\n * isDirectory('/some/path')\n *  .then((dirExists) => {\n *    // dirExists will be true or false.\n *  });\n *\n * */\nexport default function isDirectory(path: string): Promise<boolean> {\n  return fs.stat(path)\n    .then((stats) => stats.isDirectory())\n    .catch(onlyErrorsWithCode(['ENOENT', 'ENOTDIR'], () => {\n      return false;\n    }));\n}\n","/* @flow */\nimport os from 'os';\nimport path from 'path';\n\nimport requireUncached from 'require-uncached';\nimport camelCase from 'camelcase';\nimport decamelize from 'decamelize';\n\nimport fileExists from './util/file-exists';\nimport {createLogger} from './util/logger';\nimport {UsageError, WebExtError} from './errors';\n\nconst log = createLogger(__filename);\n\ntype ApplyConfigToArgvParams = {|\n  // This is the argv object which will get updated by each\n  // config applied.\n  argv: Object,\n  // This is the argv that only has CLI values applied to it.\n  argvFromCLI: Object,\n  configObject: Object,\n  options: Object,\n  configFileName: string,\n|};\n\nexport function applyConfigToArgv({\n  argv,\n  argvFromCLI,\n  configObject,\n  options,\n  configFileName,\n}: ApplyConfigToArgvParams): Object {\n  let newArgv = {...argv};\n\n  for (const option of Object.keys(configObject)) {\n    if (camelCase(option) !== option) {\n      throw new UsageError(\n        `The config option \"${option}\" must be ` +\n        `specified in camel case: \"${camelCase(option)}\"`);\n    }\n\n    // A config option cannot be a sub-command config\n    // object if it is an array.\n    if (!Array.isArray(configObject[option]) &&\n      typeof options[option] === 'object' &&\n      typeof configObject[option] === 'object') {\n      // Descend into the nested configuration for a sub-command.\n      newArgv = applyConfigToArgv({\n        argv: newArgv,\n        argvFromCLI,\n        configObject: configObject[option],\n        options: options[option],\n        configFileName});\n      continue;\n    }\n\n    const decamelizedOptName = decamelize(option, '-');\n\n    if (typeof options[decamelizedOptName] !== 'object') {\n      throw new UsageError(`The config file at ${configFileName} specified ` +\n        `an unknown option: \"${option}\"`);\n    }\n    if (options[decamelizedOptName].type === undefined) {\n      // This means yargs option type wasn't not defined correctly\n      throw new WebExtError(\n        `Option: ${option} was defined without a type.`);\n    }\n\n    const expectedType = options[decamelizedOptName].type ===\n      'count' ? 'number' : options[decamelizedOptName].type;\n\n    const optionType = (\n      Array.isArray(configObject[option]) ?\n        'array' : typeof configObject[option]\n    );\n\n    if (optionType !== expectedType) {\n      throw new UsageError(`The config file at ${configFileName} specified ` +\n        `the type of \"${option}\" incorrectly as \"${optionType}\"` +\n        ` (expected type \"${expectedType}\")`);\n    }\n\n    let defaultValue;\n    if (options[decamelizedOptName]) {\n      if (options[decamelizedOptName].default !== undefined) {\n        defaultValue = options[decamelizedOptName].default;\n      } else if (expectedType === 'boolean') {\n        defaultValue = false;\n      }\n    }\n\n    // This is our best effort (without patching yargs) to detect\n    // if a value was set on the CLI instead of in the config.\n    // It looks for a default value and if the argv value is\n    // different, it assumes that the value was configured on the CLI.\n\n    const wasValueSetOnCLI =\n      typeof argvFromCLI[option] !== 'undefined' &&\n      argvFromCLI[option] !== defaultValue;\n    if (wasValueSetOnCLI) {\n      log.debug(\n        `Favoring CLI: ${option}=${argvFromCLI[option]} over ` +\n        `configuration: ${option}=${configObject[option]}`);\n      newArgv[option] = argvFromCLI[option];\n      continue;\n    }\n\n    newArgv[option] = configObject[option];\n\n    const coerce = options[decamelizedOptName].coerce;\n    if (coerce) {\n      log.debug(\n        `Calling coerce() on configured value for ${option}`);\n      newArgv[option] = coerce(newArgv[option]);\n    }\n  }\n  return newArgv;\n}\n\nexport function loadJSConfigFile(filePath: string): Object {\n  const resolvedFilePath = path.resolve(filePath);\n  log.debug(\n    `Loading JS config file: \"${filePath}\" ` +\n    `(resolved to \"${resolvedFilePath}\")`);\n  let configObject;\n  try {\n    configObject = requireUncached(resolvedFilePath);\n  } catch (error) {\n    log.debug('Handling error:', error);\n    throw new UsageError(\n      `Cannot read config file: ${resolvedFilePath}\\n` +\n      `Error: ${error.message}`);\n  }\n  if (filePath.endsWith('package.json')) {\n    log.debug('Looking for webExt key inside package.json file');\n    configObject = configObject.webExt || {};\n  }\n  if (Object.keys(configObject).length === 0) {\n    log.debug(`Config file ${resolvedFilePath} did not define any options. ` +\n      'Did you set module.exports = {...}?');\n  }\n  return configObject;\n}\n\ntype DiscoverConfigFilesParams = {|\n  getHomeDir: () => string,\n|};\n\nexport async function discoverConfigFiles(\n  {getHomeDir = os.homedir}: DiscoverConfigFilesParams = {}\n): Promise<Array<string>> {\n  const magicConfigName = 'web-ext-config.js';\n\n  // Config files will be loaded in this order.\n  const possibleConfigs = [\n    // Look for a magic hidden config (preceded by dot) in home dir.\n    path.join(getHomeDir(), `.${magicConfigName}`),\n    // Look for webExt key inside package.json file\n    path.join(process.cwd(), 'package.json'),\n    // Look for a magic config in the current working directory.\n    path.join(process.cwd(), magicConfigName),\n  ];\n\n  const configs = await Promise.all(possibleConfigs.map(\n    async (fileName) => {\n      const resolvedFileName = path.resolve(fileName);\n      if (await fileExists(resolvedFileName)) {\n        return resolvedFileName;\n      } else {\n        log.debug(\n          `Discovered config \"${resolvedFileName}\" does not ` +\n          'exist or is not readable');\n        return undefined;\n      }\n    }\n  ));\n\n  const existingConfigs = [];\n  configs.forEach((f) => {\n    if (typeof f === 'string') {\n      existingConfigs.push(f);\n    }\n  });\n  return existingConfigs;\n}\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    Console = require(\"./console\"),\n    Memory = require(\"./memory\"),\n    DOM = require(\"./dom\"),\n    Network = require(\"./network\"),\n    StyleSheets = require(\"./stylesheets\");\n\nmodule.exports = Tab;\n\nfunction Tab(client, tab) {\n  this.initialize(client, tab.actor);\n\n  this.tab = tab;\n  this.updateInfo(tab);\n\n  this.on(\"tabNavigated\", this.onTabNavigated.bind(this));\n}\n\nTab.prototype = extend(ClientMethods, {\n  updateInfo: function(form) {\n    this.url = form.url;\n    this.title = form.title;\n  },\n\n  get StyleSheets() {\n    if (!this._StyleSheets) {\n      this._StyleSheets = new StyleSheets(this.client, this.tab.styleSheetsActor);\n    }\n    return this._StyleSheets;\n  },\n\n  get DOM() {\n    if (!this._DOM) {\n      this._DOM = new DOM(this.client, this.tab.inspectorActor);\n    }\n    return this._DOM;\n  },\n\n  get Network() {\n    if (!this._Network) {\n      this._Network = new Network(this.client, this.tab.consoleActor);\n    }\n    return this._Network;\n  },\n\n  get Console() {\n    if (!this._Console) {\n      this._Console = new Console(this.client, this.tab.consoleActor);\n    }\n    return this._Console;\n  },\n\n  get Memory() {\n    if (!this._Memory) {\n      this._Memory = new Memory(this.client, this.tab.memoryActor);\n    }\n    return this._Memory;\n  },\n\n  onTabNavigated: function(event) {\n    if (event.state == \"start\") {\n      this.emit(\"before-navigate\", { url: event.url });\n    }\n    else if (event.state == \"stop\") {\n      this.updateInfo(event);\n\n      this.emit(\"navigate\", { url: event.url, title: event.title });\n    }\n  },\n\n  attach: function(cb) {\n    this.request(\"attach\", cb);\n  },\n\n  detach: function(cb) {\n    this.request(\"detach\", cb);\n  },\n\n  reload: function(cb) {\n    this.request(\"reload\", cb);\n  },\n\n  navigateTo: function(url, cb) {\n    this.request(\"navigateTo\", { url: url }, cb);\n  }\n})\n","module.exports = require(\"net\");","module.exports = require(\"git-rev-sync\");","module.exports = require(\"events\");","var select = require(\"js-select\"),\n    extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\");\n\nmodule.exports = JSObject;\n\nfunction JSObject(client, obj) {\n  this.initialize(client, obj.actor);\n  this.obj = obj;\n}\n\nJSObject.prototype = extend(ClientMethods, {\n  type: \"object\",\n\n  get class() {\n    return this.obj.class;\n  },\n\n  get name() {\n    return this.obj.name;\n  },\n\n  get displayName() {\n    return this.obj.displayName;\n  },\n\n  ownPropertyNames: function(cb) {\n    this.request('ownPropertyNames', function(resp) {\n      return resp.ownPropertyNames;\n    }, cb);\n  },\n\n  ownPropertyDescriptor: function(name, cb) {\n    this.request('property', { name: name }, function(resp) {\n      return this.transformDescriptor(resp.descriptor);\n    }.bind(this), cb);\n  },\n\n  ownProperties: function(cb) {\n    this.request('prototypeAndProperties', function(resp) {\n      return this.transformProperties(resp.ownProperties);\n    }.bind(this), cb);\n  },\n\n  prototype: function(cb) {\n    this.request('prototype', function(resp) {\n      return this.createJSObject(resp.prototype);\n    }.bind(this), cb);\n  },\n\n  ownPropertiesAndPrototype: function(cb) {\n    this.request('prototypeAndProperties', function(resp) {\n      resp.ownProperties = this.transformProperties(resp.ownProperties);\n      resp.safeGetterValues = this.transformGetters(resp.safeGetterValues);\n      resp.prototype = this.createJSObject(resp.prototype);\n\n      return resp;\n    }.bind(this), cb);\n  },\n\n  /* helpers */\n  transformProperties: function(props) {\n    var transformed = {};\n    for (var prop in props) {\n      transformed[prop] = this.transformDescriptor(props[prop]);\n    }\n    return transformed;\n  },\n\n  transformGetters: function(getters) {\n    var transformed = {};\n    for (var prop in getters) {\n      transformed[prop] = this.transformGetter(getters[prop]);\n    }\n    return transformed;\n  },\n\n  transformDescriptor: function(descriptor) {\n    descriptor.value = this.createJSObject(descriptor.value);\n    return descriptor;\n  },\n\n  transformGetter: function(getter) {\n    return {\n      value: this.createJSObject(getter.getterValue),\n      prototypeLevel: getter.getterPrototypeLevel,\n      enumerable: getter.enumerable,\n      writable: getter.writable\n    }\n  }\n})","module.exports = require(\"js-select\");","/* @flow */\nimport os from 'os';\nimport path from 'path';\nimport {readFileSync} from 'fs';\n\nimport camelCase from 'camelcase';\nimport git from 'git-rev-sync';\nimport yargs from 'yargs';\n\nimport defaultCommands from './cmd';\nimport {UsageError} from './errors';\nimport {createLogger, consoleStream as defaultLogStream} from './util/logger';\nimport {coerceCLICustomPreference} from './firefox/preferences';\nimport {checkForUpdates as defaultUpdateChecker} from './util/updates';\nimport {\n  discoverConfigFiles as defaultConfigDiscovery,\n  loadJSConfigFile as defaultLoadJSConfigFile,\n  applyConfigToArgv as defaultApplyConfigToArgv,\n} from './config';\n\nconst log = createLogger(__filename);\nconst envPrefix = 'WEB_EXT';\n\n\ntype ProgramOptions = {|\n  absolutePackageDir?: string,\n|}\n\nexport type VersionGetterFn = (absolutePackageDir: string) => string;\n\n// TODO: add pipes to Flow type after https://github.com/facebook/flow/issues/2405 is fixed\n\ntype ExecuteOptions = {\n  checkForUpdates?: Function,\n  systemProcess?: typeof process,\n  logStream?: typeof defaultLogStream,\n  getVersion?: VersionGetterFn,\n  applyConfigToArgv?: typeof defaultApplyConfigToArgv,\n  discoverConfigFiles?: typeof defaultConfigDiscovery,\n  loadJSConfigFile?: typeof defaultLoadJSConfigFile,\n  shouldExitProgram?: boolean,\n  globalEnv?: string,\n}\n\n\n/*\n * The command line program.\n */\nexport class Program {\n  yargs: any;\n  commands: { [key: string]: Function };\n  shouldExitProgram: boolean;\n  verboseEnabled: boolean;\n  options: Object;\n\n  constructor(\n    argv: ?Array<string>,\n    {\n      absolutePackageDir = process.cwd(),\n    }: ProgramOptions = {}\n  ) {\n    // This allows us to override the process argv which is useful for\n    // testing.\n    // NOTE: process.argv.slice(2) removes the path to node and web-ext\n    // executables from the process.argv array.\n    argv = argv || process.argv.slice(2);\n\n    // NOTE: always initialize yargs explicitly with the package dir\n    // so that we are sure that it is going to load the 'boolean-negation: false'\n    // config (See web-ext#469 for rationale).\n    const yargsInstance = yargs(argv, absolutePackageDir);\n\n    this.verboseEnabled = false;\n    this.shouldExitProgram = true;\n    this.yargs = yargsInstance;\n    this.yargs.strict();\n\n    this.commands = {};\n    this.options = {};\n  }\n\n  command(\n    name: string, description: string, executor: Function,\n    commandOptions: Object = {}\n  ): Program {\n    this.options[camelCase(name)] = commandOptions;\n\n    this.yargs.command(name, description, (yargsForCmd) => {\n      if (!commandOptions) {\n        return;\n      }\n      return yargsForCmd\n        // Make sure the user does not add any extra commands. For example,\n        // this would be a mistake because lint does not accept arguments:\n        // web-ext lint ./src/path/to/file.js\n        .demandCommand(0, 0, undefined,\n                       'This command does not take any arguments')\n        .strict()\n        .exitProcess(this.shouldExitProgram)\n        // Calling env() will be unnecessary after\n        // https://github.com/yargs/yargs/issues/486 is fixed\n        .env(envPrefix)\n        .options(commandOptions);\n    });\n    this.commands[name] = executor;\n    return this;\n  }\n\n  setGlobalOptions(options: Object): Program {\n    // This is a convenience for setting global options.\n    // An option is only global (i.e. available to all sub commands)\n    // with the `global` flag so this makes sure every option has it.\n    this.options = {...this.options, ...options};\n    Object.keys(options).forEach((key) => {\n      options[key].global = true;\n      if (options[key].demand === undefined) {\n        // By default, all options should be \"demanded\" otherwise\n        // yargs.strict() will think they are missing when declared.\n        options[key].demand = true;\n      }\n    });\n    this.yargs.options(options);\n    return this;\n  }\n\n  enableVerboseMode(\n    logStream: typeof defaultLogStream,\n    version: string\n  ): void {\n    if (this.verboseEnabled) {\n      return;\n    }\n\n    logStream.makeVerbose();\n    log.info('Version:', version);\n    this.verboseEnabled = true;\n  }\n\n  async execute(\n    absolutePackageDir: string,\n    {\n      checkForUpdates = defaultUpdateChecker,\n      systemProcess = process,\n      logStream = defaultLogStream,\n      getVersion = defaultVersionGetter,\n      applyConfigToArgv = defaultApplyConfigToArgv,\n      discoverConfigFiles = defaultConfigDiscovery,\n      loadJSConfigFile = defaultLoadJSConfigFile,\n      shouldExitProgram = true,\n      globalEnv = WEBEXT_BUILD_ENV,\n    }: ExecuteOptions = {}\n  ): Promise<void> {\n    this.shouldExitProgram = shouldExitProgram;\n    this.yargs.exitProcess(this.shouldExitProgram);\n\n    const argv = this.yargs.argv;\n    const cmd = argv._[0];\n\n    const version = getVersion(absolutePackageDir);\n    const runCommand = this.commands[cmd];\n\n    if (argv.verbose) {\n      this.enableVerboseMode(logStream, version);\n    }\n\n    let adjustedArgv = {...argv};\n\n    try {\n      if (cmd === undefined) {\n        throw new UsageError('No sub-command was specified in the args');\n      }\n      if (!runCommand) {\n        throw new UsageError(`Unknown command: ${cmd}`);\n      }\n      if (globalEnv === 'production') {\n        checkForUpdates ({\n          version: getVersion(absolutePackageDir),\n        });\n      }\n\n      const configFiles = [];\n\n      if (argv.configDiscovery) {\n        log.debug(\n          'Discovering config files. ' +\n          'Set --no-config-discovery to disable');\n        const discoveredConfigs = await discoverConfigFiles();\n        configFiles.push(...discoveredConfigs);\n      } else {\n        log.debug('Not discovering config files');\n      }\n\n      if (argv.config) {\n        configFiles.push(path.resolve(argv.config));\n      }\n\n      if (configFiles.length) {\n        const niceFileList = configFiles\n          .map((f) => f.replace(process.cwd(), '.'))\n          .map((f) => f.replace(os.homedir(), '~'))\n          .join(', ');\n        log.info(\n          'Applying config file' +\n          `${configFiles.length !== 1 ? 's' : ''}: ` +\n          `${niceFileList}`);\n      }\n\n      configFiles.forEach((configFileName) => {\n        const configObject = loadJSConfigFile(configFileName);\n        adjustedArgv = applyConfigToArgv({\n          argv: adjustedArgv,\n          argvFromCLI: argv,\n          configFileName,\n          configObject,\n          options: this.options,\n        });\n      });\n\n      if (adjustedArgv.verbose) {\n        // Ensure that the verbose is enabled when specified in a config file.\n        this.enableVerboseMode(logStream, version);\n      }\n\n      await runCommand(adjustedArgv, {shouldExitProgram});\n\n    } catch (error) {\n      if (!(error instanceof UsageError) || adjustedArgv.verbose) {\n        log.error(`\\n${error.stack}\\n`);\n      } else {\n        log.error(`\\n${error}\\n`);\n      }\n      if (error.code) {\n        log.error(`Error code: ${error.code}\\n`);\n      }\n\n      log.debug(`Command executed: ${cmd}`);\n\n      if (this.shouldExitProgram) {\n        systemProcess.exit(1);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\n// A global variable generated by DefinePlugin, generated in webpack.config.js\ndeclare var WEBEXT_BUILD_ENV: string;\n\n//A defintion of type of argument for defaultVersionGetter\ntype VersionGetterOptions = {\n  globalEnv?: string,\n};\n\nexport function defaultVersionGetter(\n  absolutePackageDir: string,\n  {globalEnv = WEBEXT_BUILD_ENV}: VersionGetterOptions = {}\n): string {\n  if (globalEnv === 'production') {\n    log.debug('Getting the version from package.json');\n    const packageData: any = readFileSync(\n      path.join(absolutePackageDir, 'package.json'));\n    return JSON.parse(packageData).version;\n  } else {\n    log.debug('Getting version from the git revision');\n    return `${git.branch(absolutePackageDir)}-${git.long(absolutePackageDir)}`;\n  }\n}\n\n// TODO: add pipes to Flow type after https://github.com/facebook/flow/issues/2405 is fixed\n\ntype MainParams = {\n  getVersion?: VersionGetterFn,\n  commands?: Object,\n  argv: Array<any>,\n  runOptions?: Object,\n}\n\nexport function main(\n  absolutePackageDir: string,\n  {\n    getVersion = defaultVersionGetter, commands = defaultCommands, argv,\n    runOptions = {},\n  }: MainParams = {}\n): Promise<any> {\n\n  const program = new Program(argv, {absolutePackageDir});\n\n  // yargs uses magic camel case expansion to expose options on the\n  // final argv object. For example, the 'artifacts-dir' option is alternatively\n  // available as argv.artifactsDir.\n  program.yargs\n    .usage(`Usage: $0 [options] command\n\nOption values can also be set by declaring an environment variable prefixed\nwith $${envPrefix}_. For example: $${envPrefix}_SOURCE_DIR=/path is the same as\n--source-dir=/path.\n\nTo view specific help for any given command, add the command name.\nExample: $0 --help run.\n`)\n    .help('help')\n    .alias('h', 'help')\n    .env(envPrefix)\n    .version(() => getVersion(absolutePackageDir))\n    .demandCommand(1, 'You must specify a command')\n    .strict();\n\n  program.setGlobalOptions({\n    'source-dir': {\n      alias: 's',\n      describe: 'Web extension source directory.',\n      default: process.cwd(),\n      requiresArg: true,\n      type: 'string',\n      coerce: path.resolve,\n    },\n    'artifacts-dir': {\n      alias: 'a',\n      describe: 'Directory where artifacts will be saved.',\n      default: path.join(process.cwd(), 'web-ext-artifacts'),\n      normalize: true,\n      requiresArg: true,\n      type: 'string',\n    },\n    'verbose': {\n      alias: 'v',\n      describe: 'Show verbose output',\n      type: 'boolean',\n    },\n    'ignore-files': {\n      alias: 'i',\n      describe: 'A list of glob patterns to define which files should be ' +\n                'ignored. (Example: --ignore-files=path/to/first.js ' +\n                'path/to/second.js \"**/*.log\")',\n      demand: false,\n      requiresArg: true,\n      type: 'array',\n    },\n    'no-input': {\n      describe: 'Disable all features that require standard input',\n      type: 'boolean',\n    },\n    'config': {\n      alias: 'c',\n      describe: 'Path to a CommonJS config file to set ' +\n        'option defaults',\n      default: undefined,\n      demand: false,\n      requiresArg: true,\n      type: 'string',\n    },\n    'config-discovery': {\n      describe: 'Discover config files in home directory and ' +\n        'working directory. Disable with --no-config-discovery.',\n      demand: false,\n      default: true,\n      type: 'boolean',\n    },\n  });\n\n  program\n    .command(\n      'build',\n      'Create an extension package from source',\n      commands.build, {\n        'as-needed': {\n          describe: 'Watch for file changes and re-build as needed',\n          type: 'boolean',\n        },\n        'overwrite-dest': {\n          alias: 'o',\n          describe: 'Overwrite destination package if it exists.',\n          type: 'boolean',\n        },\n      })\n    .command(\n      'sign',\n      'Sign the extension so it can be installed in Firefox',\n      commands.sign, {\n        'api-key': {\n          describe: 'API key (JWT issuer) from addons.mozilla.org',\n          demand: true,\n          type: 'string',\n        },\n        'api-secret': {\n          describe: 'API secret (JWT secret) from addons.mozilla.org',\n          demand: true,\n          type: 'string',\n        },\n        'api-url-prefix': {\n          describe: 'Signing API URL prefix',\n          default: 'https://addons.mozilla.org/api/v3',\n          demand: true,\n          type: 'string',\n        },\n        'api-proxy': {\n          describe:\n            'Use a proxy to access the signing API. ' +\n            'Example: https://yourproxy:6000 ',\n          demand: false,\n          type: 'string',\n        },\n        'id': {\n          describe:\n            'A custom ID for the extension. This has no effect if the ' +\n            'extension already declares an explicit ID in its manifest.',\n          demand: false,\n          type: 'string',\n        },\n        'timeout': {\n          describe: 'Number of milliseconds to wait before giving up',\n          type: 'number',\n        },\n        'channel': {\n          describe: 'The channel for which to sign the addon. Either ' +\n          '\\'listed\\' or \\'unlisted\\'',\n          type: 'string',\n        },\n      })\n    .command('run', 'Run the extension', commands.run, {\n      'target': {\n        alias: 't',\n        describe: 'The extensions runners to enable (e.g. firefox-desktop, ' +\n                  'firefox-android). Specify this option multiple times to ' +\n                  'run against multiple targets.',\n        default: 'firefox-desktop',\n        demand: false,\n        type: 'array',\n      },\n      'firefox': {\n        alias: ['f', 'firefox-binary'],\n        describe: 'Path or alias to a Firefox executable such as firefox-bin ' +\n                  'or firefox.exe. ' +\n                  'If not specified, the default Firefox will be used. ' +\n                  'You can specify the following aliases in lieu of a path: ' +\n                  'firefox, beta, nightly, firefoxdeveloperedition.',\n        demand: false,\n        type: 'string',\n      },\n      'firefox-profile': {\n        alias: 'p',\n        describe: 'Run Firefox using a copy of this profile. The profile ' +\n                  'can be specified as a directory or a name, such as one ' +\n                  'you would see in the Profile Manager. If not specified, ' +\n                  'a new temporary profile will be created.',\n        demand: false,\n        type: 'string',\n      },\n      'keep-profile-changes': {\n        describe: 'Run Firefox directly in custom profile. Any changes to ' +\n                  'the profile will be saved.',\n        demand: false,\n        type: 'boolean',\n      },\n      'no-reload': {\n        describe: 'Do not reload the extension when source files change',\n        demand: false,\n        type: 'boolean',\n      },\n      'pre-install': {\n        describe: 'Pre-install the extension into the profile before ' +\n                  'startup. This is only needed to support older versions ' +\n                  'of Firefox.',\n        demand: false,\n        type: 'boolean',\n      },\n      'pref': {\n        describe: 'Launch firefox with a custom preference ' +\n                  '(example: --pref=general.useragent.locale=fr-FR). ' +\n                  'You can repeat this option to set more than one ' +\n                  'preference.',\n        demand: false,\n        requiresArg: true,\n        type: 'array',\n        coerce: coerceCLICustomPreference,\n      },\n      'start-url': {\n        alias: ['u', 'url'],\n        describe: 'Launch firefox at specified page',\n        demand: false,\n        requiresArg: true,\n        type: 'array',\n      },\n      'browser-console': {\n        alias: ['bc'],\n        describe: 'Open the DevTools Browser Console.',\n        demand: false,\n        type: 'boolean',\n      },\n      // Firefox for Android CLI options.\n      'adb-bin': {\n        describe: 'Specify a custom path to the adb binary',\n        demand: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-host': {\n        describe: 'Connect to adb on the specified host',\n        demand: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-port': {\n        describe: 'Connect to adb on the specified port',\n        demand: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'adb-device': {\n        alias: ['android-device'],\n        describe: 'Connect to the specified adb device name',\n        demand: false,\n        type: 'string',\n        requiresArg: true,\n      },\n      'firefox-apk': {\n        describe: (\n          'Run a specific Firefox for Android APK. ' +\n          'Example: org.mozilla.fennec_aurora'\n        ),\n        demand: false,\n        type: 'string',\n        requiresArg: true,\n      },\n    })\n    .command('lint', 'Validate the extension source', commands.lint, {\n      'output': {\n        alias: 'o',\n        describe: 'The type of output to generate',\n        type: 'string',\n        default: 'text',\n        choices: ['json', 'text'],\n      },\n      'metadata': {\n        describe: 'Output only metadata as JSON',\n        type: 'boolean',\n        default: false,\n      },\n      'warnings-as-errors': {\n        describe: 'Treat warnings as errors by exiting non-zero for warnings',\n        alias: 'w',\n        type: 'boolean',\n        default: false,\n      },\n      'pretty': {\n        describe: 'Prettify JSON output',\n        type: 'boolean',\n        default: false,\n      },\n      'self-hosted': {\n        describe:\n          'Your extension will be self-hosted. This disables messages ' +\n          'related to hosting on addons.mozilla.org.',\n        type: 'boolean',\n        default: false,\n      },\n      'boring': {\n        describe: 'Disables colorful shell output',\n        type: 'boolean',\n        default: false,\n      },\n    })\n    .command('docs', 'Open the web-ext documentation in a browser',\n             commands.docs, {});\n\n  return program.execute(absolutePackageDir, runOptions);\n}\n","module.exports = require(\"yargs\");","module.exports = require(\"watchpack\");","module.exports = require(\"debounce\");","/* @flow */\nimport zipDirModule from 'zip-dir';\nimport promisify from 'es6-promisify';\n\nexport const zipDir = promisify(zipDirModule);\n","module.exports = require(\"zip-dir\");","module.exports = require(\"es6-error\");","module.exports = require(\"mkdirp\");","module.exports = require(\"multimatch\");","module.exports = require(\"addons-linter\");","module.exports = require(\"node-notifier\");","module.exports = require(\"fx-runner\");","'use strict';\n\n// See https://github.com/jshint/jshint/issues/1747 for context\n/* global -Promise */\nvar Promise = require('es6-promise').Promise;\nvar FirefoxClient = require('@cliqz-oss/firefox-client');\n\nmodule.exports = connect;\n\nfunction connect(port) {\n  return new Promise(function(resolve, reject) {\n\n    var client = new FirefoxClient();\n    client.connect(port, function(err) {\n      if (err) {\n        reject(err);\n      }\n      resolve(client);\n    });\n\n    client.on('error', reject);\n    client.on('timeout', reject);\n  });\n}\n","module.exports = require(\"tmp\");","/* @flow */\nimport defaultADB from 'adbkit';\n\nimport {\n  isErrorWithCode,\n  UsageError,\n  WebExtError,\n} from '../errors';\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\n\nexport type ADBUtilsParams = {|\n  adb?: typeof defaultADB,\n  // ADB configs.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n|};\n\nexport type DiscoveryParams = {|\n  maxDiscoveryTime: number,\n  retryInterval: number,\n|};\n\n// Helper function used to raise an UsageError when the adb binary has not been found.\nasync function wrapADBCall(asyncFn: (...any) => Promise<any>): Promise<any> {\n  try {\n    return await asyncFn();\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error) &&\n        error.message.includes('spawn adb')) {\n      throw new UsageError(\n        'No adb executable has been found. ' +\n          'You can Use --adb-bin, --adb-host/--adb-port ' +\n          'to configure it manually if needed.');\n    }\n\n    throw error;\n  }\n}\n\nexport default class ADBUtils {\n  params: ADBUtilsParams;\n  adb: typeof defaultADB;\n  adbClient: any; // TODO: better flow typing here.\n\n  // Map<deviceId -> artifactsDir>\n  artifactsDirMap: Map<string, string>;\n  // Toggled when the user wants to abort the RDP Unix Socket discovery loop\n  // while it is still executing.\n  userAbortDiscovery: boolean;\n\n  constructor(params: ADBUtilsParams) {\n    this.params = params;\n\n    const {\n      adb,\n      adbBin,\n      adbHost,\n      adbPort,\n    } = params;\n\n    this.adb = adb || defaultADB;\n\n    this.adbClient = this.adb.createClient({\n      bin: adbBin,\n      host: adbHost,\n      port: adbPort,\n    });\n\n    this.artifactsDirMap = new Map();\n\n    this.userAbortDiscovery = false;\n  }\n\n  runShellCommand(\n    deviceId: string, cmd: string | Array<string>\n  ): Promise<string> {\n    const {adb, adbClient} = this;\n\n    log.debug(`Run adb shell command on ${deviceId}: ${JSON.stringify(cmd)}`);\n\n    return wrapADBCall(async () => {\n      return await adbClient.shell(deviceId, cmd).then(adb.util.readAll);\n    }).then((res) => res.toString());\n  }\n\n  async discoverDevices(): Promise<Array<string>> {\n    const {adbClient} = this;\n\n    let devices = [];\n\n    log.debug('Listing android devices');\n    devices = await wrapADBCall(async () => adbClient.listDevices());\n\n    return devices.map((dev) => dev.id);\n  }\n\n  async discoverInstalledFirefoxAPKs(\n    deviceId: string,\n    firefoxApk?: string\n  ): Promise<Array<string>> {\n    log.debug(`Listing installed Firefox APKs on ${deviceId}`);\n\n    const pmList = await this.runShellCommand(deviceId, [\n      'pm', 'list', 'packages',\n    ]);\n\n    return pmList.split('\\n')\n      .map((line) => line.replace('package:', '').trim())\n      .filter((line) => {\n        // Look for an exact match if firefoxApk is defined.\n        if (firefoxApk) {\n          return line === firefoxApk;\n        }\n        // Match any package name that starts with the package name of a Firefox for Android browser.\n        return (\n          line.startsWith('org.mozilla.fennec') ||\n            line.startsWith('org.mozilla.firefox')\n        );\n      });\n  }\n\n  async getAndroidVersionNumber(deviceId: string): Promise<number> {\n    const androidVersion = (await this.runShellCommand(deviceId, [\n      'getprop', 'ro.build.version.sdk',\n    ])).trim();\n\n    const androidVersionNumber = parseInt(androidVersion);\n\n    // No need to check the granted runtime permissions on Android versions < Lollypop.\n    if (isNaN(androidVersionNumber)) {\n      throw new WebExtError(\n        'Unable to discovery android version on ' +\n        `${deviceId}: ${androidVersion}`\n      );\n    }\n\n    return androidVersionNumber;\n  }\n\n  // Raise an UsageError when the given APK does not have the required runtime permissions.\n  async ensureRequiredAPKRuntimePermissions(\n    deviceId: string, apk: string, permissions: Array<string>\n  ): Promise<void> {\n    const permissionsMap = {};\n\n    // Initialize every permission to false in the permissions map.\n    for (const perm of permissions) {\n      permissionsMap[perm] = false;\n    }\n\n    // Retrieve the permissions information for the given apk.\n    const pmDumpLogs = (await this.runShellCommand(deviceId, [\n      'pm', 'dump', apk,\n    ])).split('\\n');\n\n    // Set to true the required permissions that have been granted.\n    for (const line of pmDumpLogs) {\n      for (const perm of permissions) {\n        if (line.includes(`${perm}: granted=true`)) {\n          permissionsMap[perm] = true;\n        }\n      }\n    }\n\n    for (const perm of permissions) {\n      if (!permissionsMap[perm]) {\n        throw new UsageError(\n          `Required ${perm} has not be granted for ${apk}. ` +\n          'Please grant them using the Android Settings ' +\n          'or using the following adb command:\\n' +\n          `\\t adb shell pm grant ${apk} ${perm}\\n`\n        );\n      }\n    }\n  }\n\n  async amForceStopAPK(deviceId: string, apk: string): Promise<void> {\n    await this.runShellCommand(deviceId, [\n      'am', 'force-stop', apk,\n    ]);\n  }\n\n  async getOrCreateArtifactsDir(deviceId: string): Promise<string> {\n    let artifactsDir = this.artifactsDirMap.get(deviceId);\n\n    if (artifactsDir) {\n      return artifactsDir;\n    }\n\n    artifactsDir = `/sdcard/web-ext-artifacts-${Date.now()}`;\n\n    const testDirOut = (await this.runShellCommand(\n      deviceId, `test -d ${artifactsDir} ; echo $?`\n    )).trim();\n\n    if (testDirOut !== '1') {\n      throw new WebExtError(\n        `Cannot create artifacts directory ${artifactsDir} ` +\n        `because it exists on ${deviceId}.`\n      );\n    }\n\n    await this.runShellCommand(deviceId, ['mkdir', '-p', artifactsDir]);\n\n    this.artifactsDirMap.set(deviceId, artifactsDir);\n\n    return artifactsDir;\n  }\n\n  async clearArtifactsDir(deviceId: string): Promise<void> {\n    const artifactsDir = this.artifactsDirMap.get(deviceId);\n\n    if (!artifactsDir) {\n      // nothing to do here.\n      return;\n    }\n\n    this.artifactsDirMap.delete(deviceId);\n\n    log.debug(\n      `Removing ${artifactsDir} artifacts directory on ${deviceId} device`\n    );\n\n    await this.runShellCommand(deviceId, [\n      'rm', '-rf', artifactsDir,\n    ]);\n  }\n\n  async pushFile(\n    deviceId: string, localPath: string, devicePath: string\n  ): Promise<void> {\n    const {adbClient} = this;\n\n    log.debug(`Pushing ${localPath} to ${devicePath} on ${deviceId}`);\n\n    await wrapADBCall(async () => {\n      await adbClient.push(deviceId, localPath, devicePath)\n        .then(function(transfer) {\n          return new Promise((resolve) => {\n            transfer.on('end', resolve);\n          });\n        });\n    });\n  }\n\n  async startFirefoxAPK(\n    deviceId: string, apk: string, deviceProfileDir: string\n  ): Promise<void> {\n    const {adbClient} = this;\n\n    log.debug(\n      `Starting ${apk} with profile ${deviceProfileDir} on ${deviceId}`\n    );\n\n    await wrapADBCall(async () => {\n      await adbClient.startActivity(deviceId, {\n        wait: true,\n        action: 'android.activity.MAIN',\n        component: `${apk}/.App`,\n        extras: [\n          {\n            key: 'args',\n            value: `-profile ${deviceProfileDir}`,\n          },\n        ],\n      });\n    });\n  }\n\n  setUserAbortDiscovery(value: boolean) {\n    this.userAbortDiscovery = value;\n  }\n\n  async discoverRDPUnixSocket(\n    deviceId: string, apk: string,\n    {maxDiscoveryTime, retryInterval}: DiscoveryParams = {}\n  ): Promise<string> {\n    let rdpUnixSockets = [];\n\n    const discoveryStartedAt = Date.now();\n\n    while (rdpUnixSockets.length === 0) {\n      if (this.userAbortDiscovery) {\n        throw new UsageError(\n          'Exiting Firefox Remote Debugging socket discovery on user request'\n        );\n      }\n\n      if (Date.now() - discoveryStartedAt > maxDiscoveryTime) {\n        throw new WebExtError(\n          'Timeout while waiting for the Android Firefox Debugger Socket'\n        );\n      }\n\n      rdpUnixSockets = (await this.runShellCommand(deviceId, [\n        'cat', '/proc/net/unix',\n      ])).split('\\n').filter((line) => {\n        // The RDP unix socket is expected to be a path in the form:\n        //   /data/data/org.mozilla.fennec_rpl/firefox-debugger-socket\n        return line.trim().endsWith(`${apk}/firefox-debugger-socket`);\n      });\n\n      if (rdpUnixSockets.length === 0) {\n        await new Promise((resolve) => setTimeout(resolve, retryInterval));\n      }\n    }\n\n    // Convert into an array of unix socket filenames.\n    rdpUnixSockets = rdpUnixSockets.map((line) => {\n      return line.trim().split(/\\s/).pop();\n    });\n\n    if (rdpUnixSockets.length > 1) {\n      throw new WebExtError(\n        'Unexpected multiple RDP sockets: ' +\n        `${JSON.stringify(rdpUnixSockets)}`\n      );\n    }\n\n    return rdpUnixSockets[0];\n  }\n\n  async setupForward(deviceId: string, remote: string, local: string) {\n    const {adbClient} = this;\n\n    // TODO(rpl): we should use adb.listForwards and reuse the existing one if any (especially\n    // because adbkit doesn't seem to support `adb forward --remote` yet).\n    log.debug(`Configuring ADB forward for ${deviceId}: ${remote} -> ${local}`);\n\n    await wrapADBCall(async () => {\n      await adbClient.forward(deviceId, local, remote);\n    });\n  }\n}\n","module.exports = require(\"adbkit\");","module.exports = require(\"sign-addon\");","module.exports = require(\"opn\");","/* @flow */\nimport defaultUpdateNotifier from 'update-notifier';\n\ntype CheckForUpdatesParams = {|\n  version: string,\n  updateNotifier?: typeof defaultUpdateNotifier,\n|};\n\nexport function checkForUpdates(\n  {\n    version,\n    updateNotifier = defaultUpdateNotifier,\n  }: CheckForUpdatesParams\n) {\n  const pkg = {name: 'web-ext', version};\n\n  updateNotifier({\n    pkg,\n    updateCheckInterval: 1000 * 60 * 60 * 24 * 3, // 3 days,\n  }).notify();\n}\n","module.exports = require(\"update-notifier\");","module.exports = require(\"require-uncached\");","module.exports = require(\"decamelize\");","/* @flow */\nimport {fs} from 'mz';\n\nimport {isErrorWithCode} from '../errors';\n\ntype FileExistsOptions = {|\n  fileIsReadable: (filePath: string) => Promise<boolean>,\n|};\n\n/*\n * Resolves true if the path is a readable file.\n *\n * Usage:\n *\n * const exists = await fileExists(filePath);\n * if (exists) {\n *   // ...\n * }\n *\n * */\nexport default async function fileExists(\n  path: string,\n  {\n    fileIsReadable = (f) => fs.access(f, fs.constants.R_OK),\n  }: FileExistsOptions = {}\n): Promise<boolean> {\n  try {\n    await fileIsReadable(path);\n    const stat = await fs.stat(path);\n    return stat.isFile();\n  } catch (error) {\n    if (isErrorWithCode(['EACCES', 'ENOENT'], error)) {\n      return false;\n    }\n    throw error;\n  }\n}\n","/* @flow */\nimport {main} from './program';\nimport cmd from './cmd';\nimport * as logger from './util/logger';\n\n// This only exposes util/logger so far.\n// Do we need anything else?\nconst util = {logger};\n\nexport default {main, cmd, util};\n","/* @flow */\nimport {createInstance as defaultLinterCreator} from 'addons-linter';\n\nimport {createLogger} from '../util/logger';\nimport {\n  createFileFilter as defaultFileFilterCreator,\n} from '../util/file-filter';\n// import flow types\nimport type {FileFilterCreatorFn} from '../util/file-filter';\n\nconst log = createLogger(__filename);\n\n\n// Define the needed 'addons-linter' module flow types.\n\nexport type LinterOutputType = 'text' | 'json';\n\nexport type LinterCreatorParams = {|\n  config: {|\n    logLevel: 'debug' | 'fatal',\n    stack: boolean,\n    pretty?: boolean,\n    warningsAsErrors?: boolean,\n    metadata?: boolean,\n    output?: LinterOutputType,\n    boring?: boolean,\n    selfHosted?: boolean,\n    shouldScanFile: (fileName: string) => boolean,\n    _: Array<string>,\n  |},\n  runAsBinary: boolean,\n|};\n\nexport type Linter = {|\n  run: () => Promise<void>,\n|};\n\nexport type LinterCreatorFn = (params: LinterCreatorParams) => Linter;\n\n\n// Lint command types and implementation.\n\nexport type LintCmdParams = {|\n  artifactsDir?: string,\n  boring?: boolean,\n  ignoreFiles?: Array<string>,\n  metadata?: boolean,\n  output?: LinterOutputType,\n  pretty?: boolean,\n  selfHosted?: boolean,\n  sourceDir: string,\n  verbose?: boolean,\n  warningsAsErrors?: boolean,\n|};\n\nexport type LintCmdOptions = {|\n  createLinter?: LinterCreatorFn,\n  createFileFilter?: FileFilterCreatorFn,\n  shouldExitProgram?: boolean,\n|};\n\nexport default function lint(\n  {\n    artifactsDir,\n    boring,\n    ignoreFiles,\n    metadata,\n    output,\n    pretty,\n    sourceDir,\n    selfHosted,\n    verbose,\n    warningsAsErrors,\n  }: LintCmdParams,\n  {\n    createLinter = defaultLinterCreator,\n    createFileFilter = defaultFileFilterCreator,\n    shouldExitProgram = true,\n  }: LintCmdOptions = {}\n): Promise<void> {\n  const fileFilter = createFileFilter({sourceDir, ignoreFiles, artifactsDir});\n\n  log.debug(`Running addons-linter on ${sourceDir}`);\n  const linter = createLinter({\n    config: {\n      logLevel: verbose ? 'debug' : 'fatal',\n      stack: Boolean(verbose),\n      pretty,\n      warningsAsErrors,\n      metadata,\n      output,\n      boring,\n      selfHosted,\n      shouldScanFile: (fileName) => fileFilter.wantFile(fileName),\n      // This mimics the first command line argument from yargs,\n      // which should be the directory to the extension.\n      _: [sourceDir],\n    },\n    runAsBinary: shouldExitProgram,\n  });\n  return linter.run();\n}\n","/* @flow */\nimport defaultBuildExtension from './build';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxClient,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\nimport defaultGetValidatedManifest from '../util/manifest';\nimport {\n  createExtensionRunner,\n  defaultReloadStrategy,\n  MultiExtensionRunner as DefaultMultiExtensionRunner,\n} from '../extension-runners';\n// Import objects that are only used as Flow types.\nimport type {FirefoxPreferences} from '../firefox/preferences';\n\nconst log = createLogger(__filename);\n\n\n// Run command types and implementation.\n\nexport type CmdRunParams = {|\n  artifactsDir: string,\n  browserConsole: boolean,\n  pref?: FirefoxPreferences,\n  firefox: string,\n  firefoxProfile?: string,\n  ignoreFiles?: Array<string>,\n  keepProfileChanges: boolean,\n  noInput?: boolean,\n  noReload: boolean,\n  preInstall: boolean,\n  sourceDir: string,\n  startUrl?: Array<string>,\n  target?: Array<string>,\n\n  // Android CLI options.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n  firefoxApk?: string,\n|};\n\nexport type CmdRunOptions = {|\n  buildExtension: typeof defaultBuildExtension,\n  desktopNotifications: typeof defaultDesktopNotifications,\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxClient,\n  reloadStrategy: typeof defaultReloadStrategy,\n  shouldExitProgram?: boolean,\n  MultiExtensionRunner?: typeof DefaultMultiExtensionRunner,\n  getValidatedManifest?: typeof defaultGetValidatedManifest,\n|};\n\nexport default async function run(\n  {\n    artifactsDir,\n    browserConsole = false,\n    pref,\n    firefox,\n    firefoxProfile,\n    keepProfileChanges = false,\n    ignoreFiles,\n    noInput = false,\n    noReload = false,\n    preInstall = false,\n    sourceDir,\n    startUrl,\n    target,\n    // Android CLI options.\n    adbBin,\n    adbHost,\n    adbPort,\n    adbDevice,\n    firefoxApk,\n  }: CmdRunParams,\n  {\n    buildExtension = defaultBuildExtension,\n    desktopNotifications = defaultDesktopNotifications,\n    firefoxApp = defaultFirefoxApp,\n    firefoxClient = defaultFirefoxClient,\n    reloadStrategy = defaultReloadStrategy,\n    MultiExtensionRunner = DefaultMultiExtensionRunner,\n    getValidatedManifest = defaultGetValidatedManifest,\n  }: CmdRunOptions = {}): Promise<DefaultMultiExtensionRunner> {\n\n  log.info(`Running web extension from ${sourceDir}`);\n  if (preInstall) {\n    log.info('Disabled auto-reloading because it\\'s not possible with ' +\n             '--pre-install');\n    noReload = true;\n  }\n\n  // Create an alias for --pref since it has been transformed into an\n  // object containing one or more preferences.\n  const customPrefs = pref;\n  const manifestData = await getValidatedManifest(sourceDir);\n\n  const runners = [];\n\n  const commonRunnerParams = {\n    // Common options.\n    extensions: [{sourceDir, manifestData}],\n    keepProfileChanges,\n    startUrl,\n    desktopNotifications,\n  };\n\n  if (!target || target.length === 0 || target.includes('firefox-desktop')) {\n    const firefoxDesktopRunnerParams = {\n      ...commonRunnerParams,\n\n      // Firefox specific CLI options.\n      firefoxBinary: firefox,\n      profilePath: firefoxProfile,\n      customPrefs,\n      browserConsole,\n      preInstall,\n\n      // Firefox runner injected dependencies.\n      firefoxApp,\n      firefoxClient,\n    };\n\n    const firefoxDesktopRunner = await createExtensionRunner({\n      target: 'firefox-desktop',\n      params: firefoxDesktopRunnerParams,\n    });\n    runners.push(firefoxDesktopRunner);\n  }\n\n  if (target && target.includes('firefox-android')) {\n    const firefoxAndroidRunnerParams = {\n      ...commonRunnerParams,\n\n      // Firefox specific CLI options.\n      profilePath: firefoxProfile,\n      customPrefs,\n      browserConsole,\n      preInstall,\n      firefoxApk,\n      adbDevice,\n      adbHost,\n      adbPort,\n      adbBin,\n\n      // Injected dependencies.\n      firefoxApp,\n      firefoxClient,\n      desktopNotifications: defaultDesktopNotifications,\n      buildSourceDir: (extensionSourceDir: string, tmpArtifactsDir: string) => {\n        return buildExtension({\n          sourceDir: extensionSourceDir,\n          ignoreFiles,\n          asNeeded: false,\n          // Use a separate temporary directory for building the extension zip file\n          // that we are going to upload on the android device.\n          artifactsDir: tmpArtifactsDir,\n        }, {\n          // Suppress the message usually logged by web-ext build.\n          showReadyMessage: false,\n        });\n      },\n    };\n\n    const firefoxAndroidRunner = await createExtensionRunner({\n      target: 'firefox-android',\n      params: firefoxAndroidRunnerParams,\n    });\n    runners.push(firefoxAndroidRunner);\n  }\n\n  const extensionRunner = new MultiExtensionRunner({\n    desktopNotifications,\n    runners,\n  });\n\n  await extensionRunner.run();\n\n  if (noReload) {\n    log.info('Automatic extension reloading has been disabled');\n  } else {\n    log.info('The extension will reload if any source file changes');\n\n    reloadStrategy({\n      extensionRunner,\n      sourceDir,\n      artifactsDir,\n      ignoreFiles,\n      noInput,\n    });\n  }\n\n  return extensionRunner;\n}\n","module.exports = require(\"es6-promise\");","module.exports = require(\"./lib/browser\");","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    Client = require(\"./client\"),\n    Tab = require(\"./tab\"),\n    Webapps = require(\"./webapps\"),\n    Device = require(\"./device\"),\n    SimulatorApps = require(\"./simulator\");\n\nconst DEFAULT_PORT = 6000;\nconst DEFAULT_HOST = \"localhost\";\n\nmodule.exports = FirefoxClient;\n\nfunction FirefoxClient(options) {\n  var client = new Client(options);\n  var actor = 'root';\n\n  client.on(\"error\", this.onError.bind(this));\n  client.on(\"end\", this.onEnd.bind(this));\n  client.on(\"timeout\", this.onTimeout.bind(this));\n\n  this.initialize(client, actor);\n}\n\nFirefoxClient.prototype = extend(ClientMethods, {\n  connect: function(port, host, cb) {\n    if (typeof port == \"function\") {\n      // (cb)\n      cb = port;\n      port = DEFAULT_PORT;\n      host = DEFAULT_HOST;\n\n    }\n    if (typeof host == \"function\") {\n      // (port, cb)\n      cb = host;\n      host = DEFAULT_HOST;\n    }\n    // (port, host, cb)\n\n    this.client.connect(port, host, cb);\n\n    this.client.expectReply(this.actor, function(packet) {\n      // root message\n    });\n  },\n\n  disconnect: function() {\n    this.client.disconnect();\n  },\n\n  onError: function(error) {\n    this.emit(\"error\", error);\n  },\n\n  onEnd: function() {\n    this.emit(\"end\");\n  },\n\n  onTimeout: function() {\n    this.emit(\"timeout\");\n  },\n\n  selectedTab: function(cb) {\n    this.request(\"listTabs\", function(resp) {\n      var tab = resp.tabs[resp.selected];\n      return new Tab(this.client, tab);\n    }.bind(this), cb);\n  },\n\n  listTabs: function(cb) {\n    this.request(\"listTabs\", function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      if (resp.simulatorWebappsActor) {\n        // the server is the Firefox OS Simulator, return apps as \"tabs\"\n        var apps = new SimulatorApps(this.client, resp.simulatorWebappsActor);\n        apps.listApps(cb);\n      }\n      else {\n        var tabs = resp.tabs.map(function(tab) {\n          return new Tab(this.client, tab);\n        }.bind(this));\n        cb(null, tabs);\n      }\n    }.bind(this));\n  },\n\n  getWebapps: function(cb) {\n    this.request(\"listTabs\", (function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n      var webapps = new Webapps(this.client, resp);\n      cb(null, webapps);\n    }).bind(this));\n  },\n\n  getDevice: function(cb) {\n    this.request(\"listTabs\", (function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n      var device = new Device(this.client, resp);\n      cb(null, device);\n    }).bind(this));\n  },\n\n  getRoot: function(cb) {\n    this.request(\"listTabs\", (function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n      if (!resp.consoleActor) {\n        return cb(\"No root actor being available.\");\n      }\n      var root = new Tab(this.client, resp);\n      cb(null, root);\n    }).bind(this));\n  }\n})\n","var net = require(\"net\"),\n    events = require(\"events\"),\n    extend = require(\"./extend\");\n\nvar colors = require(\"colors\");\n\nmodule.exports = Client;\n\n// this is very unfortunate! and temporary. we can't\n// rely on 'type' property to signify an event, and we\n// need to write clients for each actor to handle differences\n// in actor protocols\nvar unsolicitedEvents = {\n  \"tabNavigated\": \"tabNavigated\",\n  \"styleApplied\": \"styleApplied\",\n  \"propertyChange\": \"propertyChange\",\n  \"networkEventUpdate\": \"networkEventUpdate\",\n  \"networkEvent\": \"networkEvent\",\n  \"propertyChange\": \"propertyChange\",\n  \"newMutations\": \"newMutations\",\n  \"appOpen\": \"appOpen\",\n  \"appClose\": \"appClose\",\n  \"appInstall\": \"appInstall\",\n  \"appUninstall\": \"appUninstall\",\n  \"frameUpdate\": \"frameUpdate\",\n  \"tabListChanged\": \"tabListChanged\"\n};\n\n/**\n * a Client object handles connecting with a Firefox remote debugging\n * server instance (e.g. a Firefox instance), plus sending and receiving\n * packets on that conection using the Firefox remote debugging protocol.\n *\n * Important methods:\n * connect - Create the connection to the server.\n * makeRequest - Make a request to the server with a JSON message,\n *   and a callback to call with the response.\n *\n * Important events:\n * 'message' - An unsolicited (e.g. not a response to a prior request)\n *    packet has been received. These packets usually describe events.\n */\nfunction Client(options) {\n  this.options = options || {};\n\n  this.incoming = new Buffer(\"\");\n\n  this._pendingRequests = [];\n  this._activeRequests = {};\n}\n\nClient.prototype = extend(events.EventEmitter.prototype, {\n  connect: function(port, host, cb) {\n    this.client = net.createConnection({\n      port: port,\n      host: host\n    });\n\n    this.client.on(\"connect\", cb);\n    this.client.on(\"data\", this.onData.bind(this));\n    this.client.on(\"error\", this.onError.bind(this));\n    this.client.on(\"end\", this.onEnd.bind(this));\n    this.client.on(\"timeout\", this.onTimeout.bind(this));\n  },\n\n  disconnect: function() {\n    if (this.client) {\n      this.client.end();\n    }\n  },\n\n  /**\n   * Set a request to be sent to an actor on the server. If the actor\n   * is already handling a request, queue this request until the actor\n   * has responded to the previous request.\n   *\n   * @param {object} request\n   *        Message to be JSON-ified and sent to server.\n   * @param {function} callback\n   *        Function that's called with the response from the server.\n   */\n  makeRequest: function(request, callback) {\n    this.log(\"request: \" + JSON.stringify(request).green);\n\n    if (!request.to) {\n      var type = request.type || \"\";\n      throw new Error(type + \" request packet has no destination.\");\n    }\n    this._pendingRequests.push({ to: request.to,\n                                 message: request,\n                                 callback: callback });\n    this._flushRequests();\n  },\n\n  /**\n   * Activate (send) any pending requests to actors that don't have an\n   * active request.\n   */\n  _flushRequests: function() {\n    this._pendingRequests = this._pendingRequests.filter(function(request) {\n      // only one active request per actor at a time\n      if (this._activeRequests[request.to]) {\n        return true;\n      }\n\n      // no active requests for this actor, so activate this one\n      this.sendMessage(request.message);\n      this.expectReply(request.to, request.callback);\n\n      // remove from pending requests\n      return false;\n    }.bind(this));\n  },\n\n  /**\n   * Send a JSON message over the connection to the server.\n   */\n  sendMessage: function(message) {\n    if (!message.to) {\n      throw new Error(\"No actor specified in request\");\n    }\n    if (!this.client) {\n      throw new Error(\"Not connected, connect() before sending requests\");\n    }\n    var str = JSON.stringify(message);\n\n    // message is preceded by byteLength(message):\n    str = (new Buffer(str).length) + \":\" + str;\n\n    this.client.write(str);\n  },\n\n  /**\n   * Arrange to hand the next reply from |actor| to |handler|.\n   */\n  expectReply: function(actor, handler) {\n    if (this._activeRequests[actor]) {\n      throw Error(\"clashing handlers for next reply from \" + uneval(actor));\n    }\n    this._activeRequests[actor] = handler;\n  },\n\n  /**\n   * Handler for a new message coming in. It's either an unsolicited event\n   * from the server, or a response to a previous request from the client.\n   */\n  handleMessage: function(message) {\n    if (!message.from) {\n      if (message.error) {\n        throw new Error(message.message);\n      }\n      throw new Error(\"Server didn't specify an actor: \" + JSON.stringify(message));\n    }\n\n    if (!(message.type in unsolicitedEvents)\n        && this._activeRequests[message.from]) {\n      this.log(\"response: \" + JSON.stringify(message).yellow);\n\n      var callback = this._activeRequests[message.from];\n      delete this._activeRequests[message.from];\n\n      callback(message);\n\n      this._flushRequests();\n    }\n    else if (message.type) {\n      // this is an unsolicited event from the server\n      this.log(\"unsolicited event: \".grey + JSON.stringify(message).grey);\n\n      this.emit('message', message);\n      return;\n    }\n    else {\n      throw new Error(\"Unexpected packet from actor \" +  message.from\n      +  JSON.stringify(message));\n    }\n  },\n\n  /**\n   * Called when a new data chunk is received on the connection.\n   * Parse data into message(s) and call message handler for any full\n   * messages that are read in.\n   */\n  onData: function(data) {\n    this.incoming = Buffer.concat([this.incoming, data]);\n\n    while(this.readMessage()) {};\n  },\n\n  /**\n   * Parse out and process the next message from the data read from\n   * the connection. Returns true if a full meassage was parsed, false\n   * otherwise.\n   */\n  readMessage: function() {\n    var sep = this.incoming.toString().indexOf(':');\n    if (sep < 0) {\n      return false;\n    }\n\n    // beginning of a message is preceded by byteLength(message) + \":\"\n    var count = parseInt(this.incoming.slice(0, sep));\n\n    if (this.incoming.length - (sep + 1) < count) {\n      this.log(\"no complete response yet\".grey);\n      return false;\n    }\n    this.incoming = this.incoming.slice(sep + 1);\n\n    var packet = this.incoming.slice(0, count);\n\n    this.incoming = this.incoming.slice(count);\n\n    var message;\n    try {\n      message = JSON.parse(packet.toString());\n    } catch(e) {\n      throw new Error(\"Couldn't parse packet from server as JSON \" + e\n        + \", message:\\n\" + packet);\n    }\n    this.handleMessage(message);\n\n    return true;\n  },\n\n  onError: function(error) {\n    var code = error.code ? error.code : error;\n    this.log(\"connection error: \".red + code.red);\n    this.emit(\"error\", error);\n  },\n\n  onEnd: function() {\n    this.log(\"connection closed by server\".red);\n    this.emit(\"end\");\n  },\n\n  onTimeout: function() {\n    this.log(\"connection timeout\".red);\n    this.emit(\"timeout\");\n  },\n\n  log: function(str) {\n    if (this.options.log) {\n      console.log(str);\n    }\n  }\n})\n","module.exports = require(\"colors\");","var select = require(\"js-select\"),\n    extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    JSObject = require(\"./jsobject\");\n\nmodule.exports = Console;\n\nfunction Console(client, actor) {\n  this.initialize(client, actor);\n\n  this.on(\"consoleAPICall\", this.onConsoleAPI.bind(this));\n  this.on(\"pageError\", this.onPageError.bind(this));\n}\n\nConsole.prototype = extend(ClientMethods, {\n  types: [\"PageError\", \"ConsoleAPI\"],\n\n  /**\n   * Response object:\n   *   -empty-\n   */\n  startListening: function(cb) {\n    this.request('startListeners', { listeners: this.types }, cb);\n  },\n\n  /**\n   * Response object:\n   *   -empty-\n   */\n  stopListening: function(cb) {\n    this.request('stopListeners', { listeners: this.types }, cb);\n  },\n\n  /**\n   * Event object:\n   *   level - \"log\", etc.\n   *   filename - file with call\n   *   lineNumber - line number of call\n   *   functionName - function log called from\n   *   timeStamp - ms timestamp of call\n   *   arguments - array of the arguments to log call\n   *   private -\n   */\n  onConsoleAPI: function(event) {\n    var message = this.transformConsoleCall(event.message);\n\n    this.emit(\"console-api-call\", message);\n  },\n\n  /**\n   * Event object:\n   *   errorMessage - string error message\n   *   sourceName - file error\n   *   lineText\n   *   lineNumber - line number of error\n   *   columnNumber - column number of error\n   *   category - usually \"content javascript\",\n   *   timeStamp - time in ms of error occurance\n   *   warning - whether it's a warning\n   *   error - whether it's an error\n   *   exception - whether it's an exception\n   *   strict -\n   *   private -\n   */\n  onPageError: function(event) {\n    this.emit(\"page-error\", event.pageError);\n  },\n\n  /**\n   * Response object: array of page error or console call objects.\n   */\n  getCachedLogs: function(cb) {\n    var message = {\n      messageTypes: this.types\n    };\n    this.request('getCachedMessages', message, function(resp) {\n      select(resp, \".messages > *\").update(this.transformConsoleCall.bind(this));\n      return resp.messages;\n    }.bind(this), cb);\n  },\n\n  /**\n   * Response object:\n   *   -empty-\n   */\n  clearCachedLogs: function(cb) {\n    this.request('clearMessagesCache', cb);\n  },\n\n  /**\n   * Response object:\n   *   input - original input\n   *   result - result of the evaluation, a value or JSObject\n   *   timestamp - timestamp in ms of the evaluation\n   *   exception - any exception as a result of the evaluation\n   */\n  evaluateJS: function(text, cb) {\n    this.request('evaluateJS', { text: text }, function(resp) {\n      return select(resp, \".result, .exception\")\n             .update(this.createJSObject.bind(this));\n    }.bind(this), cb)\n  },\n\n  transformConsoleCall: function(message) {\n    return select(message, \".arguments > *\").update(this.createJSObject.bind(this));\n  }\n})\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\");\n\nmodule.exports = Memory;\n\nfunction Memory(client, actor) {\n  this.initialize(client, actor);\n}\n\nMemory.prototype = extend(ClientMethods, {\n  measure: function(cb) {\n    this.request('measure', function (err, resp) {\n      cb(err, resp);\n    });\n  }\n})\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    Node = require(\"./domnode\");\n\nmodule.exports = DOM;\n\nfunction DOM(client, actor) {\n  this.initialize(client, actor);\n  this.walker = null;\n}\n\nDOM.prototype = extend(ClientMethods, {\n  document: function(cb) {\n    this.walkerRequest(\"document\", function(err, resp) {\n      if (err) return cb(err);\n\n      var node = new Node(this.client, this.walker, resp.node);\n      cb(null, node);\n    }.bind(this))\n  },\n\n  documentElement: function(cb) {\n    this.walkerRequest(\"documentElement\", function(err, resp) {\n      var node = new Node(this.client, this.walker, resp.node);\n      cb(err, node);\n    }.bind(this))\n  },\n\n  querySelector: function(selector, cb) {\n    this.document(function(err, node) {\n      if (err) return cb(err);\n\n      node.querySelector(selector, cb);\n    })\n  },\n\n  querySelectorAll: function(selector, cb) {\n    this.document(function(err, node) {\n      if (err) return cb(err);\n\n      node.querySelectorAll(selector, cb);\n    })\n  },\n\n  getComputedStyle: function(node, cb) {\n    this.styleRequest(\"getComputed\", { node: node.actor },\n                      this.pluck('computed'), cb);\n  },\n\n  getUsedFontFaces: function(node, options, cb) {\n    var message = {\n      node: node.actor,\n      includePreviews: options.includePreviews,\n      previewText: options.previewText,\n      previewFontSize: options.previewFontSize\n    };\n\n    this.styleRequest(\"getUsedFontFaces\", message,\n                      this.pluck('fontFaces'), cb);\n  },\n\n  getFontPreview: function(node, font, cb) {\n    this.styleRequest(\"getFontPreview\", { node: node.actor, font: font }, cb);\n  },\n\n  walkerRequest: function(type, message, cb) {\n    this.getWalker(function(err, walker) {\n      walker.request(type, message, cb);\n    });\n  },\n\n  getWalker: function(cb) {\n    if (this.walker) {\n      return cb(null, this.walker);\n    }\n    this.request('getWalker', function(err, resp) {\n      this.walker = new Walker(this.client, resp.walker);\n      cb(err, this.walker);\n    }.bind(this))\n  },\n\n  styleRequest: function(type, message, transform, cb) {\n    this.getStyle(function(err, style) {\n      if (err) throw err;\n\n      style.request(type, message, transform, cb);\n    })\n  },\n\n  getStyle: function(cb) {\n    if (this.style) {\n      return cb(null, this.style);\n    }\n    this.request('getPageStyle', function(err, resp) {\n      this.style = new Style(this.client, resp.pageStyle);\n      cb(err, this.style);\n    }.bind(this))\n  }\n})\n\nfunction Walker(client, walker) {\n  this.initialize(client, walker.actor);\n\n  this.root = new Node(client, this, walker.root);\n}\n\nWalker.prototype = extend(ClientMethods, {});\n\nfunction Style(client, style) {\n  this.initialize(client, style.actor);\n}\n\nStyle.prototype = extend(ClientMethods, {});\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\");\n\nmodule.exports = Node;\n\nfunction Node(client, walker, node) {\n  this.initialize(client, node.actor);\n  this.walker = walker;\n\n  this.getNode = this.getNode.bind(this);\n  this.getNodeArray = this.getNodeArray.bind(this);\n  this.getNodeList = this.getNodeList.bind(this);\n\n  walker.on('newMutations', function(event) {\n    //console.log(\"on new mutations! \", JSON.stringify(event));\n  });\n\n  ['nodeType', 'nodeName', 'namespaceURI', 'attrs']\n  .forEach(function(attr) {\n    this[attr] = node[attr];\n  }.bind(this));\n}\n\nNode.prototype = extend(ClientMethods, {\n  getAttribute: function(name) {\n    for (var i in this.attrs) {\n      var attr = this.attrs[i];\n      if (attr.name == name) {\n        return attr.value;\n      }\n    }\n  },\n\n  setAttribute: function(name, value, cb) {\n    var mods = [{\n      attributeName: name,\n      newValue: value\n    }];\n    this.request('modifyAttributes', { modifications: mods }, cb);\n  },\n\n  parentNode: function(cb) {\n    this.parents(function(err, nodes) {\n      if (err) {\n        return cb(err);\n      }\n      var node = null;\n      if (nodes.length) {\n        node = nodes[0];\n      }\n      cb(null, node);\n    })\n  },\n\n  parents: function(cb) {\n    this.nodeRequest('parents', this.getNodeArray, cb);\n  },\n\n  children: function(cb) {\n    this.nodeRequest('children', this.getNodeArray, cb);\n  },\n\n  siblings: function(cb) {\n    this.nodeRequest('siblings', this.getNodeArray, cb);\n  },\n\n  nextSibling: function(cb) {\n    this.nodeRequest('nextSibling', this.getNode, cb);\n  },\n\n  previousSibling: function(cb) {\n    this.nodeRequest('previousSibling', this.getNode, cb);\n  },\n\n  querySelector: function(selector, cb) {\n    this.nodeRequest('querySelector', { selector: selector },\n                     this.getNode, cb);\n  },\n\n  querySelectorAll: function(selector, cb) {\n    this.nodeRequest('querySelectorAll', { selector: selector },\n                     this.getNodeList, cb);\n  },\n\n  getUniqueSelector: function(cb) {\n    this.request('getUniqueSelector', cb);\n  },\n\n  innerHTML: function(cb) {\n    this.nodeRequest('innerHTML', function(resp) {\n      return resp.value;\n    }, cb)\n  },\n\n  outerHTML: function(cb) {\n    this.nodeRequest('outerHTML', function(resp) {\n      return resp.value;\n    }, cb)\n  },\n\n  remove: function(cb) {\n    this.nodeRequest('removeNode', function(resp) {\n      return new Node(this.client, this.walker, resp.nextSibling);\n    }.bind(this), cb);\n  },\n\n  highlight: function(cb) {\n    this.nodeRequest('highlight', cb);\n  },\n\n  release: function(cb) {\n    this.nodeRequest('releaseNode', cb);\n  },\n\n  getNode: function(resp) {\n    if (resp.node) {\n      return new Node(this.client, this.walker, resp.node);\n    }\n    return null;\n  },\n\n  getNodeArray: function(resp) {\n    return resp.nodes.map(function(form) {\n      return new Node(this.client, this.walker, form);\n    }.bind(this));\n  },\n\n  getNodeList: function(resp) {\n    return new NodeList(this.client, this.walker, resp.list);\n  },\n\n  nodeRequest: function(type, message, transform, cb) {\n    if (!cb) {\n      cb = transform;\n      transform = message;\n      message = {};\n    }\n    message.node = this.actor;\n\n    this.walker.request(type, message, transform, cb);\n  }\n});\n\nfunction NodeList(client, walker, list) {\n  this.client = client;\n  this.walker = walker;\n  this.actor = list.actor;\n\n  this.length = list.length;\n}\n\nNodeList.prototype = extend(ClientMethods, {\n  items: function(start, end, cb) {\n    if (typeof start == \"function\") {\n      cb = start;\n      start = 0;\n      end = this.length;\n    }\n    else if (typeof end == \"function\") {\n      cb = end;\n      end = this.length;\n    }\n    this.request('items', { start: start, end: end },\n      this.getNodeArray.bind(this), cb);\n  },\n\n  // TODO: add this function to ClientMethods\n  getNodeArray: function(resp) {\n    return resp.nodes.map(function(form) {\n      return new Node(this.client, this.walker, form);\n    }.bind(this));\n  }\n});\n","var extend = require(\"./extend\");\nvar ClientMethods = require(\"./client-methods\");\n\nmodule.exports = Network;\n\nfunction Network(client, actor) {\n  this.initialize(client, actor);\n\n  this.on(\"networkEvent\", this.onNetworkEvent.bind(this));\n}\n\nNetwork.prototype = extend(ClientMethods, {\n  types: [\"NetworkActivity\"],\n\n  startLogging: function(cb) {\n    this.request('startListeners', { listeners: this.types }, cb);\n  },\n\n  stopLogging: function(cb) {\n    this.request('stopListeners', { listeners: this.types }, cb);\n  },\n\n  onNetworkEvent: function(event) {\n    var networkEvent = new NetworkEvent(this.client, event.eventActor);\n\n    this.emit(\"network-event\", networkEvent);\n  },\n\n  sendHTTPRequest: function(request, cb) {\n    this.request('sendHTTPRequest', { request: request }, function(resp) {\n      return new NetworkEvent(this.client, resp.eventActor);\n    }.bind(this), cb);\n  }\n})\n\nfunction NetworkEvent(client, event) {\n  this.initialize(client, event.actor);\n  this.event = event;\n\n  this.on(\"networkEventUpdate\", this.onUpdate.bind(this));\n}\n\nNetworkEvent.prototype = extend(ClientMethods, {\n  get url() {\n   return this.event.url;\n  },\n\n  get method() {\n    return this.event.method;\n  },\n\n  get isXHR() {\n    return this.event.isXHR;\n  },\n\n  getRequestHeaders: function(cb) {\n    this.request('getRequestHeaders', cb);\n  },\n\n  getRequestCookies: function(cb) {\n    this.request('getRequestCookies', this.pluck('cookies'), cb);\n  },\n\n  getRequestPostData: function(cb) {\n    this.request('getRequestPostData', cb);\n  },\n\n  getResponseHeaders: function(cb) {\n    this.request('getResponseHeaders', cb);\n  },\n\n  getResponseCookies: function(cb) {\n    this.request('getResponseCookies', this.pluck('cookies'), cb);\n  },\n\n  getResponseContent: function(cb) {\n    this.request('getResponseContent', cb);\n  },\n\n  getEventTimings: function(cb) {\n    this.request('getEventTimings', cb);\n  },\n\n  onUpdate: function(event) {\n    var types = {\n      \"requestHeaders\": \"request-headers\",\n      \"requestCookies\": \"request-cookies\",\n      \"requestPostData\": \"request-postdata\",\n      \"responseStart\": \"response-start\",\n      \"responseHeaders\": \"response-headers\",\n      \"responseCookies\": \"response-cookies\",\n      \"responseContent\": \"response-content\",\n      \"eventTimings\": \"event-timings\"\n    }\n\n    var type = types[event.updateType];\n    delete event.updateType;\n\n    this.emit(type, event);\n  }\n})\n\n\n\n\n","var extend = require(\"./extend\");\nvar ClientMethods = require(\"./client-methods\");\n\nmodule.exports = StyleSheets;\n\nfunction StyleSheets(client, actor) {\n  this.initialize(client, actor);\n}\n\nStyleSheets.prototype = extend(ClientMethods, {\n  getStyleSheets: function(cb) {\n    this.request('getStyleSheets', function(resp) {\n      return resp.styleSheets.map(function(sheet) {\n        return new StyleSheet(this.client, sheet);\n      }.bind(this));\n    }.bind(this), cb);\n  },\n\n  addStyleSheet: function(text, cb) {\n    this.request('addStyleSheet', { text: text }, function(resp) {\n      return new StyleSheet(this.client, resp.styleSheet);\n    }.bind(this), cb);\n  }\n})\n\nfunction StyleSheet(client, sheet) {\n  this.initialize(client, sheet.actor);\n  this.sheet = sheet;\n\n  this.on(\"propertyChange\", this.onPropertyChange.bind(this));\n}\n\nStyleSheet.prototype = extend(ClientMethods, {\n  get href() {\n    return this.sheet.href;\n  },\n\n  get disabled() {\n    return this.sheet.disabled;\n  },\n\n  get ruleCount() {\n    return this.sheet.ruleCount;\n  },\n\n  onPropertyChange: function(event) {\n    this.sheet[event.property] = event.value;\n    this.emit(event.property + \"-changed\", event.value);\n  },\n\n  toggleDisabled: function(cb) {\n    this.request('toggleDisabled', function(err, resp) {\n      if (err) return cb(err);\n\n      this.sheet.disabled = resp.disabled;\n      cb(null, resp.disabled);\n    }.bind(this));\n  },\n\n  getOriginalSources: function(cb) {\n    this.request('getOriginalSources', function(resp) {\n      if (resp.originalSources === null) {\n        return [];\n      }\n      return resp.originalSources.map(function(form) {\n        return new OriginalSource(this.client, form);\n      }.bind(this));\n    }.bind(this), cb);\n  },\n\n  getMediaRules: function(cb) {\n    this.request('getMediaRules', function(resp) {\n      return resp.mediaRules.map(function(form) {\n        return new MediaRule(this.client, form);\n      }.bind(this));\n    }.bind(this), cb);\n  },\n\n  update: function(text, cb) {\n    this.request('update', { text: text, transition: true }, cb);\n  },\n\n  getText: function(cb) {\n    this.request('getText', this.pluck('text'), cb);\n  }\n});\n\nfunction MediaRule(client, rule) {\n  this.initialize(client, rule.actor);\n  this.rule = rule;\n\n  this.on(\"matchesChange\", function(event) {\n    this.emit(\"matches-change\", event.matches);\n  }.bind(this));\n}\nMediaRule.prototype = extend(ClientMethods, {\n  get mediaText() {\n    return this.rule.mediaText;\n  },\n\n  get matches() {\n    return this.rule.matches;\n  }\n})\n\nfunction OriginalSource(client, source) {\n  console.log(\"source\", source);\n  this.initialize(client, source.actor);\n\n  this.source = source;\n}\n\nOriginalSource.prototype = extend(ClientMethods, {\n  get url()  {\n    return this.source.url\n  },\n\n  getText: function(cb) {\n    this.request('getText', this.pluck('text'), cb);\n  }\n});\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    Tab = require(\"./tab\"),\n    fs = require(\"fs\"),\n    spawn = require(\"child_process\").spawn;\n\nmodule.exports = Webapps;\n\nvar CHUNK_SIZE = 20480;\n\n// Also dispatch appOpen/appClose, appInstall/appUninstall events\nfunction Webapps(client, tab) {\n  this.initialize(client, tab.webappsActor);\n}\n\nWebapps.prototype = extend(ClientMethods, {\n  watchApps: function(cb) {\n    this.request(\"watchApps\", cb);\n  },\n  unwatchApps: function(cb) {\n    this.request(\"unwatchApps\", cb);\n  },\n  launch: function(manifestURL, cb) {\n    this.request(\"launch\", {manifestURL: manifestURL}, cb);\n  },\n  close: function(manifestURL, cb) {\n    this.request(\"close\", {manifestURL: manifestURL}, cb);\n  },\n  getInstalledApps: function(cb) {\n    this.request(\"getAll\", function (err, resp) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      cb(null, resp.apps);\n    });\n  },\n  listRunningApps: function(cb) {\n    this.request(\"listRunningApps\", function (err, resp) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      cb(null, resp.apps);\n    });\n  },\n  getApp: function(manifestURL, cb) {\n    this.request(\"getAppActor\", {manifestURL: manifestURL}, (function (err, resp) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      var actor = new Tab(this.client, resp.actor);\n      cb(null, actor);\n    }).bind(this));\n  },\n  installHosted: function(options, cb) {\n    this.request(\n      \"install\",\n      { appId: options.appId,\n        metadata: options.metadata,\n        manifest: options.manifest },\n      function (err, resp) {\n        if (err || resp.error) {\n          cb(err || resp.error);\n          return;\n        }\n        cb(null, resp.appId);\n      });\n  },\n  _upload: function (path, cb) {\n    // First create an upload actor\n    this.request(\"uploadPackage\", function (err, resp) {\n      var actor = resp.actor;\n      fs.readFile(path, function(err, data) {\n        chunk(actor, data);\n      });\n    });\n    // Send push the file chunk by chunk\n    var self = this;\n    var step = 0;\n    function chunk(actor, data) {\n      var i = step++ * CHUNK_SIZE;\n      var m = Math.min(i + CHUNK_SIZE, data.length);\n      var c = \"\";\n      for(; i < m; i++)\n        c += String.fromCharCode(data[i]);\n      var message = {\n        to: actor,\n        type: \"chunk\",\n        chunk: c\n      };\n      self.client.makeRequest(message, function(resp) {\n        if (resp.error) {\n          cb(resp);\n          return;\n        }\n        if (i < data.length) {\n          setTimeout(chunk, 0, actor, data);\n        } else {\n          done(actor);\n        }\n      });\n    }\n    // Finally close the upload\n    function done(actor) {\n      var message = {\n        to: actor,\n        type: \"done\"\n      };\n      self.client.makeRequest(message, function(resp) {\n        if (resp.error) {\n          cb(resp);\n        } else {\n          cb(null, actor, cleanup.bind(null, actor));\n        }\n      });\n    }\n\n    // Remove the temporary uploaded file from the server:\n    function cleanup(actor) {\n      var message = {\n        to: actor,\n        type: \"remove\"\n      };\n      self.client.makeRequest(message, function () {});\n    }\n  },\n  installPackaged: function(path, appId, cb) {\n    this._upload(path, (function (err, actor, cleanup) {\n      this.request(\"install\", {appId: appId, upload: actor},\n        function (err, resp) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          cb(null, resp.appId);\n          cleanup();\n        });\n    }).bind(this));\n  },\n  installPackagedWithADB: function(path, appId, cb) {\n    var self = this;\n    // First ensure the temporary folder exists\n    function createTemporaryFolder() {\n      var c = spawn(\"adb\", [\"shell\", \"mkdir -p /data/local/tmp/b2g/\" + appId], {stdio:\"inherit\"});\n      c.on(\"close\", uploadPackage);\n    }\n    // then upload the package to the temporary directory\n    function uploadPackage() {\n      var child = spawn(\"adb\", [\"push\", path, \"/data/local/tmp/b2g/\" + appId + \"/application.zip\"], {stdio:\"inherit\"});\n      child.on(\"close\", installApp);\n    }\n    // finally order the webapps actor to install the app\n    function installApp() {\n      self.request(\"install\", {appId: appId},\n        function (err, resp) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          cb(null, resp.appId);\n        });\n    }\n    createTemporaryFolder();\n  },\n  uninstall: function(manifestURL, cb) {\n    this.request(\"uninstall\", {manifestURL: manifestURL}, cb);\n  }\n})\n","module.exports = require(\"child_process\");","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\");\n\nmodule.exports = Device;\n\nfunction Device(client, tab) {\n  this.initialize(client, tab.deviceActor);\n}\n\nDevice.prototype = extend(ClientMethods, {\n  getDescription: function(cb) {\n    this.request(\"getDescription\", function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, resp.value);\n    });\n  },\n  getRawPermissionsTable: function(cb) {\n    this.request(\"getRawPermissionsTable\", function(err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      cb(null, resp.value.rawPermissionsTable);\n    });\n  }\n})\n","var extend = require(\"./extend\"),\n    ClientMethods = require(\"./client-methods\"),\n    Tab = require(\"./tab\");\n\nmodule.exports = SimulatorApps;\n\nfunction SimulatorApps(client, actor) {\n  this.initialize(client, actor);\n}\n\nSimulatorApps.prototype = extend(ClientMethods, {\n  listApps: function(cb) {\n    this.request('listApps', function(resp) {\n      var apps = [];\n      for (var url in resp.apps) {\n        var app = resp.apps[url];\n        apps.push(new Tab(this.client, app));\n      }\n      return apps;\n    }.bind(this), cb);\n  }\n})\n","/* @flow */\n\n/**\n * This module provide an ExtensionRunner subclass that manage an extension executed\n * in a Firefox for Desktop instance.\n */\n\n// Import flow types from npm dependencies.\nimport type FirefoxProfile from 'firefox-profile';\n\nimport {\n  MultiExtensionsReloadError,\n  RemoteTempInstallNotSupported,\n  WebExtError,\n} from '../errors';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxConnector,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\n// Import flow types from project files.\nimport type {\n  FirefoxRDPResponseAddon,\n  RemoteFirefox,\n} from '../firefox/remote';\nimport type {\n  ExtensionRunnerParams,\n  ExtensionRunnerReloadResult,\n} from './base';\nimport type {FirefoxPreferences} from '../firefox/preferences';\nimport type {FirefoxInfo} from '../firefox/index'; // eslint-disable-line import/named\n\ntype FirefoxDesktopSpecificRunnerParams = {|\n  customPrefs?: FirefoxPreferences,\n  browserConsole: boolean,\n  firefoxBinary: string,\n  preInstall: boolean,\n\n  // Firefox desktop injected dependencies.\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxConnector,\n|};\n\nexport type FirefoxDesktopExtensionRunnerParams = {|\n  ...ExtensionRunnerParams,\n  // Firefox desktop CLI params.\n  ...FirefoxDesktopSpecificRunnerParams,\n|};\n\nconst log = createLogger(__filename);\n\n/**\n * Implements an IExtensionRunner which manages a Firefox Desktop instance.\n */\nexport class FirefoxDesktopExtensionRunner {\n  cleanupCallbacks: Set<Function>;\n  params: FirefoxDesktopExtensionRunnerParams;\n  profile: FirefoxProfile;\n  // Map extensions sourceDir to their related addon ids.\n  reloadableExtensions: Map<string, string>;\n  remoteFirefox: RemoteFirefox;\n  runningInfo: FirefoxInfo;\n\n  constructor(params: FirefoxDesktopExtensionRunnerParams) {\n    this.params = params;\n\n    this.reloadableExtensions = new Map();\n    this.cleanupCallbacks = new Set();\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Firefox Desktop';\n  }\n\n  /**\n   * Setup the Firefox Profile and run a Firefox Desktop instance.\n   */\n  async run(): Promise<void> {\n    // Get a firefox profile with the custom Prefs set (a new or a cloned one).\n    // Pre-install extensions as proxy if needed (and disable auto-reload if you do)\n    await this.setupProfileDir();\n\n    // (if reload is enabled):\n    // - Connect to the firefox instance on RDP\n    // - Install any extension if needed (if not installed as proxy)\n    // - Keep track of the extension id assigned in a map with the sourceDir as a key\n    await this.startFirefoxInstance();\n  }\n\n  /**\n   * Reloads all the extensions, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const reloadErrors = new Map();\n    for (const {sourceDir} of this.params.extensions) {\n      const [res] = await this.reloadExtensionBySourceDir(sourceDir);\n      if (res.reloadError instanceof Error) {\n        reloadErrors.set(sourceDir, res.reloadError);\n      }\n    }\n\n    if (reloadErrors.size > 0) {\n      return [{\n        runnerName,\n        reloadError: new MultiExtensionsReloadError(reloadErrors),\n      }];\n    }\n\n    return [{runnerName}];\n  }\n\n  /**\n   * Reloads a single extension, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadExtensionBySourceDir(\n    extensionSourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const addonId = this.reloadableExtensions.get(extensionSourceDir);\n\n    if (!addonId) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: new WebExtError(\n          'Extension not reloadable: ' +\n          `no addonId has been mapped to \"${extensionSourceDir}\"`\n        ),\n        runnerName,\n      }];\n    }\n\n    try {\n      await this.remoteFirefox.reloadAddon(addonId);\n    } catch (error) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: error,\n        runnerName,\n      }];\n    }\n\n    return [{runnerName, sourceDir: extensionSourceDir}];\n  }\n\n  /**\n   * Register a callback to be called when the runner has been exited\n   * (e.g. the Firefox instance exits or the user has requested web-ext\n   * to exit).\n   */\n  registerCleanup(fn: Function): void {\n    this.cleanupCallbacks.add(fn);\n  }\n\n  /**\n   * Exits the runner, by closing the managed Firefox instance.\n   */\n  async exit(): Promise<void> {\n    if (!this.runningInfo || !this.runningInfo.firefox) {\n      throw new WebExtError('No firefox instance is currently running');\n    }\n\n    this.runningInfo.firefox.kill();\n  }\n\n  // Private helper methods.\n\n  async setupProfileDir() {\n    const {\n      customPrefs,\n      extensions,\n      keepProfileChanges,\n      preInstall,\n      profilePath,\n      firefoxApp,\n    } = this.params;\n\n    if (profilePath) {\n      if (keepProfileChanges) {\n        log.debug(`Using Firefox profile from ${profilePath}`);\n        this.profile = await firefoxApp.useProfile(profilePath, {customPrefs});\n      } else {\n        log.debug(`Copying Firefox profile from ${profilePath}`);\n        this.profile = await firefoxApp.copyProfile(profilePath, {customPrefs});\n      }\n    } else {\n      log.debug('Creating new Firefox profile');\n      this.profile = await firefoxApp.createProfile({customPrefs});\n    }\n\n    // preInstall the extensions if needed.\n    if (preInstall) {\n      for (const extension of extensions) {\n        await firefoxApp.installExtension({\n          asProxy: true,\n          extensionPath: extension.sourceDir,\n          manifestData: extension.manifestData,\n          profile: this.profile,\n        });\n      }\n    }\n  }\n\n  async startFirefoxInstance() {\n    const {\n      browserConsole,\n      extensions,\n      firefoxBinary,\n      preInstall,\n      startUrl,\n      firefoxApp,\n      firefoxClient,\n    } = this.params;\n\n    const binaryArgs = [];\n\n    if (browserConsole) {\n      binaryArgs.push('-jsconsole');\n    }\n    if (startUrl) {\n      const urls = Array.isArray(startUrl) ? startUrl : [startUrl];\n      for (const url of urls) {\n        binaryArgs.push('--url', url);\n      }\n    }\n\n    this.runningInfo = await firefoxApp.run(this.profile, {\n      firefoxBinary, binaryArgs,\n    });\n\n    this.runningInfo.firefox.on('close', () => {\n      for (const cleanupCb of this.cleanupCallbacks) {\n        try {\n          cleanupCb();\n        } catch (error) {\n          log.error(`Exception on executing cleanup callback: ${error}`);\n        }\n      }\n    });\n\n    if (!preInstall) {\n      const remoteFirefox = this.remoteFirefox = await firefoxClient({\n        port: this.runningInfo.debuggerPort,\n      });\n\n      // Install all the temporary addons.\n      for (const extension of extensions) {\n        try {\n          const addonId = await (\n            remoteFirefox.installTemporaryAddon(extension.sourceDir)\n              .then((installResult: FirefoxRDPResponseAddon) => {\n                return installResult.addon.id;\n              })\n          );\n\n          if (!addonId) {\n            throw new WebExtError(\n              'Unexpected missing addonId in the installAsTemporaryAddon result'\n            );\n          }\n\n          this.reloadableExtensions.set(extension.sourceDir, addonId);\n        } catch (error) {\n          if (error instanceof RemoteTempInstallNotSupported) {\n            log.debug(`Caught: ${error}`);\n            throw new WebExtError(\n              'Temporary add-on installation is not supported in this version' +\n              ' of Firefox (you need Firefox 49 or higher). For older Firefox' +\n              ' versions, use --pre-install'\n            );\n          } else {\n            throw error;\n          }\n        }\n      }\n    }\n  }\n}\n","/* @flow */\n\n/**\n * This module provide an ExtensionRunner subclass that manage an extension executed\n * in a Firefox for Android instance.\n */\n\nimport net from 'net';\nimport path from 'path';\nimport readline from 'readline';\n\nimport {withTempDir} from '../util/temp-dir';\nimport DefaultADBUtils from '../util/adb';\nimport {\n  showDesktopNotification as defaultDesktopNotifications,\n} from '../util/desktop-notifier';\nimport {\n  MultiExtensionsReloadError,\n  UsageError,\n  WebExtError,\n} from '../errors';\nimport * as defaultFirefoxApp from '../firefox';\nimport {\n  connectWithMaxRetries as defaultFirefoxConnector,\n} from '../firefox/remote';\nimport {createLogger} from '../util/logger';\nimport {isTTY, setRawMode} from '../util/stdin';\nimport type {\n  ExtensionRunnerParams,\n  ExtensionRunnerReloadResult,\n} from './base';\nimport type {\n  FirefoxPreferences,\n} from '../firefox/preferences';\nimport type {\n  FirefoxRDPResponseAddon,\n  RemoteFirefox,\n} from '../firefox/remote';\nimport type {\n  ExtensionBuildResult,\n} from '../cmd/build';\n\nconst log = createLogger(__filename);\n\nexport type FirefoxAndroidExtensionRunnerParams = {|\n  ...ExtensionRunnerParams,\n\n  // Firefox specific.\n  customPrefs?: FirefoxPreferences,\n\n  // Not supported (currently ignored with logged warning).\n  preInstall?: boolean,\n  browserConsole?: boolean,\n\n  // Firefox android injected dependencies.\n  adbBin?: string,\n  adbHost?: string,\n  adbPort?: string,\n  adbDevice?: string,\n  firefoxApk?: string,\n  firefoxAndroidTimeout?: number,\n\n  // Injected Dependencies.\n  firefoxApp: typeof defaultFirefoxApp,\n  firefoxClient: typeof defaultFirefoxConnector,\n  ADBUtils?: typeof DefaultADBUtils,\n  buildSourceDir: (string, string) => Promise<ExtensionBuildResult>,\n  desktopNotifications: typeof defaultDesktopNotifications,\n  stdin?: stream$Readable,\n|};\n\n/**\n * Implements an IExtensionRunner which manages a Firefox for Android instance.\n */\nexport class FirefoxAndroidExtensionRunner {\n  // Wait 3s before the next unix socket discovery loop.\n  static unixSocketDiscoveryRetryInterval = 3 * 1000;\n  // Wait for at most 3 minutes before giving up.\n  static unixSocketDiscoveryMaxTime = 3 * 60 * 1000;\n\n  params: FirefoxAndroidExtensionRunnerParams;\n  adbUtils: DefaultADBUtils;\n  exiting: boolean;\n  selectedAdbDevice: string;\n  selectedFirefoxApk: string;\n  selectedArtifactsDir: string;\n  selectedRDPSocketFile: string;\n  selectedTCPPort: number;\n  cleanupCallbacks: Set<Function>;\n  adbExtensionsPathBySourceDir: Map<string, string>;\n  reloadableExtensions: Map<string, string>;\n  remoteFirefox: RemoteFirefox;\n\n  constructor(params: FirefoxAndroidExtensionRunnerParams) {\n    this.params = params;\n    this.cleanupCallbacks = new Set();\n    this.adbExtensionsPathBySourceDir = new Map();\n    this.reloadableExtensions = new Map();\n\n    // Print warning for not currently supported options (e.g. preInstall,\n    // cloned profiles, browser console).\n    this.printIgnoredParamsWarnings();\n  }\n\n  async run(): Promise<void> {\n    const {\n      adbBin,\n      adbHost,\n      adbPort,\n      ADBUtils = DefaultADBUtils,\n    } = this.params;\n\n    this.adbUtils = new ADBUtils({\n      adbBin, adbHost, adbPort,\n    });\n\n    await this.adbDevicesDiscoveryAndSelect();\n    await this.apkPackagesDiscoveryAndSelect();\n    await this.adbCheckRuntimePermissions();\n    await this.adbForceStopSelectedPackage();\n\n    // Create profile prefs (with enabled remote RDP server), prepare the\n    // artifacts and temporary directory on the selected device, and\n    // push the profile preferences to the remote profile dir.\n    await this.adbPrepareProfileDir();\n\n    // NOTE: running Firefox for Android on the Android Emulator can be\n    // pretty slow, we can run the following 3 steps in parallel to speed up\n    // it a bit.\n    await Promise.all([\n      // Start Firefox for Android instance on the created profile.\n      this.adbStartSelectedPackage(),\n\n      // Build and push to devices all the extension xpis\n      // and keep track of the xpi built and uploaded by extension sourceDir.\n      this.buildAndPushExtensions(),\n\n      // Wait for RDP unix socket file created and\n      // Create an ADB forward connection on a free tcp port\n      this.adbDiscoveryAndForwardRDPUnixSocket(),\n    ]);\n\n    // Connect to RDP socket on the local tcp server, install all the pushed extension\n    // and keep track of the built and installed extension by extension sourceDir.\n    await this.rdpInstallExtensions();\n  }\n\n  // Method exported from the IExtensionRunner interface.\n\n  /**\n   * Returns the runner name.\n   */\n  getName() {\n    return 'Firefox Android';\n  }\n\n  /**\n   * Reloads all the extensions, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadAllExtensions(): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const reloadErrors = new Map();\n\n    for (const {sourceDir} of this.params.extensions) {\n      const [res] = await this.reloadExtensionBySourceDir(sourceDir);\n      if (res.reloadError instanceof Error) {\n        reloadErrors.set(sourceDir, res.reloadError);\n      }\n    }\n\n    if (reloadErrors.size > 0) {\n      return [{\n        runnerName,\n        reloadError: new MultiExtensionsReloadError(reloadErrors),\n      }];\n    }\n\n    return [{runnerName}];\n  }\n\n  /**\n   * Reloads a single extension, collect any reload error and resolves to\n   * an array composed by a single ExtensionRunnerReloadResult object.\n   */\n  async reloadExtensionBySourceDir(\n    extensionSourceDir: string\n  ): Promise<Array<ExtensionRunnerReloadResult>> {\n    const runnerName = this.getName();\n    const addonId = this.reloadableExtensions.get(extensionSourceDir);\n\n    if (!addonId) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: new WebExtError(\n          'Extension not reloadable: ' +\n            `no addonId has been mapped to \"${extensionSourceDir}\"`\n        ),\n        runnerName,\n      }];\n    }\n\n    try {\n      await this.buildAndPushExtension(extensionSourceDir);\n      await this.remoteFirefox.reloadAddon(addonId);\n    } catch (error) {\n      return [{\n        sourceDir: extensionSourceDir,\n        reloadError: error,\n        runnerName,\n      }];\n    }\n\n    return [{runnerName, sourceDir: extensionSourceDir}];\n  }\n\n  /**\n   * Register a callback to be called when the runner has been exited\n   * (e.g. the Firefox instance exits or the user has requested web-ext\n   * to exit).\n   */\n  registerCleanup(fn: Function): void {\n    this.cleanupCallbacks.add(fn);\n  }\n\n  /**\n   * Exits the runner, by closing the managed Firefox instance.\n   */\n  async exit(): Promise<void> {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedArtifactsDir,\n    } = this;\n\n    this.exiting = true;\n\n    // If a Firefox for Android instance has been started,\n    // we should ensure that it has been stopped when we exit.\n    await this.adbForceStopSelectedPackage();\n\n    if (selectedArtifactsDir) {\n      log.debug('Cleaning up artifacts directory on the Android device...');\n      await adbUtils.clearArtifactsDir(selectedAdbDevice);\n    }\n\n    // Call all the registered cleanup callbacks.\n    for (const fn of this.cleanupCallbacks) {\n      try {\n        fn();\n      } catch (error) {\n        log.error(error);\n      }\n    }\n  }\n\n  // Private helper methods.\n\n  getDeviceProfileDir(): string {\n    return `${this.selectedArtifactsDir}/profile`;\n  }\n\n  printIgnoredParamsWarnings() {\n    if (this.params.profilePath) {\n      log.warn(\n        'Firefox for Android target does not support custom profile paths.'\n      );\n    }\n\n    if (this.params.keepProfileChanges) {\n      log.warn(\n        'Firefox for Android target does not support --keep-profile-changes.'\n      );\n    }\n\n    if (this.params.browserConsole) {\n      log.warn(\n        'Firefox for Android target does not support --browser-console option.'\n      );\n    }\n\n    if (this.params.preInstall) {\n      log.warn(\n        'Firefox for Android target does not support --pre-install option.'\n      );\n    }\n\n    if (this.params.startUrl) {\n      log.warn(\n        'Firefox for Android target does not support --start-url option.'\n      );\n    }\n  }\n\n  async adbDevicesDiscoveryAndSelect() {\n    const {adbUtils} = this;\n    const {adbDevice} = this.params;\n    let devices = [];\n\n    log.debug('Listing android devices');\n    devices = await adbUtils.discoverDevices();\n\n    if (devices.length === 0) {\n      throw new UsageError(\n        'No Android device found through ADB. ' +\n        'Make sure the device is connected and USB debugging is enabled.'\n      );\n    }\n\n    if (!adbDevice) {\n      const devicesMsg = devices.map((dev) => ` - ${dev}`).join('\\n');\n      log.info(`\\nAndroid devices found:\\n${devicesMsg}`);\n      throw new UsageError(\n        'Select an android device using --android-device=<name>');\n    }\n\n    const foundDevices = devices.filter((device) => {\n      return device === adbDevice;\n    });\n\n    if (foundDevices.length === 0) {\n      const devicesMsg = JSON.stringify(devices);\n      throw new UsageError(\n        `Android device ${adbDevice} was not found in list: ${devicesMsg}`);\n    }\n\n    this.selectedAdbDevice = foundDevices[0];\n    log.info(`Selected ADB device: ${this.selectedAdbDevice}`);\n  }\n\n  async apkPackagesDiscoveryAndSelect() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      params: {\n        firefoxApk,\n      },\n    } = this;\n    // Discovery and select a Firefox for Android version.\n    const packages = await adbUtils.discoverInstalledFirefoxAPKs(\n      selectedAdbDevice,\n      firefoxApk\n    );\n\n    if (packages.length === 0) {\n      throw new UsageError(\n        'No Firefox packages were found on the selected Android device');\n    }\n\n    const pkgsListMsg = (pkgs) => {\n      return pkgs.map((pkg) => ` - ${ pkg}`).join('\\n');\n    };\n\n    if (!firefoxApk) {\n      log.info(`\\nPackages found:\\n${pkgsListMsg(packages)}`);\n\n      if (packages.length > 1) {\n        throw new UsageError('Select one of the packages using --firefox-apk');\n      }\n\n      // If only one APK has been found, select it even if it has not been\n      // specified explicitly on the comment line.\n      this.selectedFirefoxApk = packages[0];\n      log.info(`Selected Firefox for Android APK: ${this.selectedFirefoxApk}`);\n      return;\n    }\n\n    const filteredPackages = packages.filter((line) => line === firefoxApk);\n\n    if (filteredPackages.length === 0) {\n      const pkgsList = pkgsListMsg(filteredPackages);\n      throw new UsageError(\n        `Package ${firefoxApk} was not found in list: ${pkgsList}`\n      );\n    }\n\n    this.selectedFirefoxApk = filteredPackages[0];\n    log.debug(`Selected Firefox for Android APK: ${this.selectedFirefoxApk}`);\n  }\n\n  async adbForceStopSelectedPackage() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n    } = this;\n\n    log.info(`Stopping existing instances of ${selectedFirefoxApk}...`);\n    await adbUtils.amForceStopAPK(selectedAdbDevice, selectedFirefoxApk);\n  }\n\n  async adbCheckRuntimePermissions() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n    } = this;\n\n    log.debug(`Discovering Android version for ${selectedAdbDevice}...`);\n\n    const androidVersion = await adbUtils.getAndroidVersionNumber(\n      selectedAdbDevice\n    );\n\n    if (typeof androidVersion !== 'number' || Number.isNaN(androidVersion)) {\n      throw new WebExtError(`Invalid Android version: ${androidVersion}`);\n    }\n\n    log.debug(`Detected Android version ${androidVersion}`);\n\n    if (androidVersion < 23) {\n      return;\n    }\n\n    log.debug('Checking read/write permissions needed for web-ext' +\n              `on ${selectedFirefoxApk}...`);\n\n    // Runtime permission needed to be able to run Firefox on a temporarily created profile\n    // on android versions >= 23 (Android Marshmallow, which is the first version where\n    // these permissions are optional and have to be granted explicitly).\n    await adbUtils.ensureRequiredAPKRuntimePermissions(\n      selectedAdbDevice, selectedFirefoxApk, [\n        'android.permission.READ_EXTERNAL_STORAGE',\n        'android.permission.WRITE_EXTERNAL_STORAGE',\n      ]\n    );\n  }\n\n  async adbPrepareProfileDir() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n      params: {\n        firefoxApp,\n      },\n    } = this;\n    // Create the preferences file and the Fennec temporary profile.\n    log.debug(`Preparing a temporary profile for ${selectedFirefoxApk}...`);\n\n    const profile = await firefoxApp.createProfile({app: 'fennec'});\n\n    // Choose a artifacts dir name for the assets pushed to the\n    // Android device.\n    this.selectedArtifactsDir = await adbUtils.getOrCreateArtifactsDir(\n      selectedAdbDevice\n    );\n\n    const deviceProfileDir = this.getDeviceProfileDir();\n\n    await adbUtils.runShellCommand(selectedAdbDevice, [\n      'mkdir', '-p', deviceProfileDir,\n    ]);\n    await adbUtils.pushFile(selectedAdbDevice,\n                            path.join(profile.profileDir, 'user.js'),\n                            `${deviceProfileDir}/user.js`);\n\n    log.debug(`Created temporary profile at ${deviceProfileDir}.`);\n  }\n\n  async adbStartSelectedPackage() {\n    const {\n      adbUtils,\n      selectedFirefoxApk,\n      selectedAdbDevice,\n    } = this;\n\n    const deviceProfileDir = this.getDeviceProfileDir();\n\n    log.info(`Starting ${selectedFirefoxApk}...`);\n\n    log.debug(`Using profile ${deviceProfileDir}`);\n\n    await adbUtils.startFirefoxAPK(\n      selectedAdbDevice, selectedFirefoxApk, deviceProfileDir\n    );\n  }\n\n  async buildAndPushExtension(sourceDir: string) {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedArtifactsDir,\n      params: {\n        buildSourceDir,\n      },\n    } = this;\n\n    await withTempDir(async (tmpDir) => {\n      const {extensionPath} = await buildSourceDir(sourceDir, tmpDir.path());\n\n      const extFileName = path.basename(extensionPath, '.zip');\n\n      let adbExtensionPath = this.adbExtensionsPathBySourceDir.get(sourceDir);\n\n      if (!adbExtensionPath) {\n        adbExtensionPath = `${selectedArtifactsDir}/${extFileName}.xpi`;\n      }\n\n      log.debug(`Uploading ${extFileName} on the android device`);\n\n      await adbUtils.pushFile(\n        selectedAdbDevice, extensionPath, adbExtensionPath\n      );\n\n      log.debug(`Upload completed: ${adbExtensionPath}`);\n\n      this.adbExtensionsPathBySourceDir.set(sourceDir, adbExtensionPath);\n    });\n  }\n\n  async buildAndPushExtensions() {\n    for (const {sourceDir} of this.params.extensions) {\n      await this.buildAndPushExtension(sourceDir);\n    }\n  }\n\n  async adbDiscoveryAndForwardRDPUnixSocket() {\n    const {\n      adbUtils,\n      selectedAdbDevice,\n      selectedFirefoxApk,\n      params: {\n        firefoxAndroidTimeout,\n      },\n    } = this;\n\n    const stdin = this.params.stdin || process.stdin;\n\n    const {\n      unixSocketDiscoveryRetryInterval,\n    } = FirefoxAndroidExtensionRunner;\n\n    let {\n      unixSocketDiscoveryMaxTime,\n    } = FirefoxAndroidExtensionRunner;\n\n    if (typeof firefoxAndroidTimeout === 'number') {\n      unixSocketDiscoveryMaxTime = firefoxAndroidTimeout;\n    }\n\n    const handleCtrlC = (str, key) => {\n      if (key.ctrl && key.name === 'c') {\n        adbUtils.setUserAbortDiscovery(true);\n      }\n    };\n\n    // TODO: use noInput property to decide if we should\n    // disable direct keypress handling.\n    if (isTTY(stdin)) {\n      readline.emitKeypressEvents(stdin);\n      setRawMode(stdin, true);\n\n      stdin.on('keypress', handleCtrlC);\n    }\n\n    try {\n      // Got a debugger socket file to connect.\n      this.selectedRDPSocketFile = (\n        await adbUtils.discoverRDPUnixSocket(\n          selectedAdbDevice, selectedFirefoxApk, {\n            maxDiscoveryTime: unixSocketDiscoveryMaxTime,\n            retryInterval: unixSocketDiscoveryRetryInterval,\n          }\n        )\n      );\n    } finally {\n      if (isTTY(stdin)) {\n        stdin.removeListener('keypress', handleCtrlC);\n      }\n    }\n\n    log.debug(`RDP Socket File selected: ${this.selectedRDPSocketFile}`);\n\n    const tcpPort = await this.chooseLocalTcpPort();\n\n    // Log the choosen tcp port at info level (useful to the user to be able\n    // to connect the Firefox DevTools to the Firefox for Android instance).\n    log.info(`You can connect to this Android device on TCP port ${tcpPort}`);\n\n    const forwardSocketSpec = this.selectedRDPSocketFile.startsWith('@') ?\n      `localabstract:${this.selectedRDPSocketFile.substr(1)}`\n      : `localfilesystem:${this.selectedRDPSocketFile}`;\n\n    await adbUtils.setupForward(\n      selectedAdbDevice,\n      forwardSocketSpec,\n      `tcp:${tcpPort}`\n    );\n\n    this.selectedTCPPort = tcpPort;\n  }\n\n  chooseLocalTcpPort(): Promise<number> {\n    return new Promise((resolve) => {\n      const srv = net.createServer();\n      // $FLOW_FIXME: flow has his own opinions on this method signature.\n      srv.listen(0, () => {\n        const freeTcpPort = srv.address().port;\n        srv.close();\n        resolve(freeTcpPort);\n      });\n    });\n  }\n\n  async rdpInstallExtensions() {\n    const {\n      selectedTCPPort,\n      params: {\n        extensions,\n        firefoxClient,\n      },\n    } = this;\n\n    const remoteFirefox = this.remoteFirefox = await firefoxClient({\n      port: selectedTCPPort,\n    });\n\n    // Exit and cleanup the extension runner if the connection to the\n    // remote Firefox for Android instance has been closed.\n    remoteFirefox.client.on('end', () => {\n      if (!this.exiting) {\n        log.info('Exiting the device because Firefox for Android disconnected');\n        this.exit();\n      }\n    });\n\n    // Install all the temporary addons.\n    for (const extension of extensions) {\n      const {sourceDir} = extension;\n      const adbExtensionPath = this.adbExtensionsPathBySourceDir.get(\n        sourceDir\n      );\n\n      if (!adbExtensionPath) {\n        throw new WebExtError(\n          `ADB extension path for \"${sourceDir}\" was unexpectedly empty`\n        );\n      }\n\n      const addonId = await (\n        remoteFirefox.installTemporaryAddon(adbExtensionPath)\n          .then((installResult: FirefoxRDPResponseAddon) => {\n            return installResult.addon.id;\n          })\n      );\n\n      if (!addonId) {\n        throw new WebExtError(\n          'Received an empty addonId from ' +\n          `remoteFirefox.installTemporaryAddon(\"${adbExtensionPath}\")`\n        );\n      }\n\n      this.reloadableExtensions.set(extension.sourceDir, addonId);\n    }\n  }\n}\n","/* @flow */\nimport path from 'path';\n\nimport {fs} from 'mz';\nimport defaultAddonSigner from 'sign-addon';\n\nimport defaultBuilder from './build';\nimport getValidatedManifest, {getManifestId} from '../util/manifest';\nimport {withTempDir} from '../util/temp-dir';\nimport {isErrorWithCode, UsageError, WebExtError} from '../errors';\nimport {prepareArtifactsDir} from '../util/artifacts';\nimport {createLogger} from '../util/logger';\nimport type {ExtensionManifest} from '../util/manifest';\n\n\nconst log = createLogger(__filename);\n\nconst defaultAsyncFsReadFile = fs.readFile.bind(fs);\n\nexport const extensionIdFile = '.web-extension-id';\n\n// Sign command types and implementation.\n\nexport type SignParams = {|\n  apiKey: string,\n  apiProxy: string,\n  apiSecret: string,\n  apiUrlPrefix: string,\n  artifactsDir: string,\n  id?: string,\n  ignoreFiles?: Array<string>,\n  sourceDir: string,\n  timeout: number,\n  verbose?: boolean,\n  channel?: string,\n|};\n\nexport type SignOptions = {\n  build?: typeof defaultBuilder,\n  signAddon?: typeof defaultAddonSigner,\n  preValidatedManifest?: ExtensionManifest,\n  shouldExitProgram?: boolean,\n};\n\nexport type SignResult = {|\n  success: boolean,\n  id: string,\n  downloadedFiles: Array<string>,\n|};\n\nexport default function sign(\n  {\n    apiKey,\n    apiProxy,\n    apiSecret,\n    apiUrlPrefix,\n    artifactsDir,\n    id,\n    ignoreFiles = [],\n    sourceDir,\n    timeout,\n    verbose,\n    channel,\n  }: SignParams,\n  {\n    build = defaultBuilder,\n    preValidatedManifest,\n    signAddon = defaultAddonSigner,\n  }: SignOptions = {}\n): Promise<SignResult> {\n  return withTempDir(\n    async function(tmpDir) {\n      await prepareArtifactsDir(artifactsDir);\n\n      let manifestData;\n\n      if (preValidatedManifest) {\n        manifestData = preValidatedManifest;\n      } else {\n        manifestData = await getValidatedManifest(sourceDir);\n      }\n\n      const [buildResult, idFromSourceDir] = await Promise.all([\n        build({sourceDir, ignoreFiles, artifactsDir: tmpDir.path()},\n              {manifestData, showReadyMessage: false}),\n        getIdFromSourceDir(sourceDir),\n      ]);\n\n      const manifestId = getManifestId(manifestData);\n\n      if (id && manifestId) {\n        throw new UsageError(\n          `Cannot set custom ID ${id} because manifest.json ` +\n          `declares ID ${manifestId}`);\n      }\n      if (id) {\n        log.debug(`Using custom ID declared as --id=${id}`);\n      }\n\n      if (manifestId) {\n        id = manifestId;\n      }\n\n      if (!id && idFromSourceDir) {\n        log.info(\n          `Using previously auto-generated extension ID: ${idFromSourceDir}`);\n        id = idFromSourceDir;\n      }\n\n      if (!id) {\n        log.warn('No extension ID specified (it will be auto-generated)');\n      }\n\n      const signingResult = await signAddon({\n        apiKey,\n        apiSecret,\n        apiUrlPrefix,\n        apiProxy,\n        timeout,\n        verbose,\n        id,\n        xpiPath: buildResult.extensionPath,\n        version: manifestData.version,\n        downloadDir: artifactsDir,\n        channel,\n      });\n\n      if (signingResult.id) {\n        await saveIdToSourceDir(sourceDir, signingResult.id);\n      }\n\n      // All information about the downloaded files would have\n      // already been logged by signAddon().\n      if (signingResult.success) {\n        log.info(`Extension ID: ${signingResult.id}`);\n        log.info('SUCCESS');\n      } else {\n        log.info('FAIL');\n        throw new WebExtError(\n          'The extension could not be signed');\n      }\n\n      return signingResult;\n    }\n  );\n}\n\n\nexport async function getIdFromSourceDir(\n  sourceDir: string,\n  asyncFsReadFile: typeof defaultAsyncFsReadFile = defaultAsyncFsReadFile,\n): Promise<string | void> {\n  const filePath = path.join(sourceDir, extensionIdFile);\n\n  let content;\n\n  try {\n    content = await asyncFsReadFile(filePath);\n  } catch (error) {\n    if (isErrorWithCode('ENOENT', error)) {\n      log.debug(`No ID file found at: ${filePath}`);\n      return;\n    }\n    throw error;\n  }\n\n  let lines = content.toString().split('\\n');\n  lines = lines.filter((line) => {\n    line = line.trim();\n    if (line && !line.startsWith('#')) {\n      return line;\n    }\n  });\n\n  const id = lines[0];\n  log.debug(`Found extension ID ${id} in ${filePath}`);\n\n  if (!id) {\n    throw new UsageError(`No ID found in extension ID file ${filePath}`);\n  }\n\n  return id;\n}\n\n\nexport async function saveIdToSourceDir(\n  sourceDir: string, id: string\n): Promise<void> {\n  const filePath = path.join(sourceDir, extensionIdFile);\n  await fs.writeFile(filePath, [\n    '# This file was created by https://github.com/mozilla/web-ext',\n    '# Your auto-generated extension ID for addons.mozilla.org is:',\n    id.toString(),\n  ].join('\\n'));\n\n  log.debug(`Saved auto-generated ID ${id} to ${filePath}`);\n}\n","/* @flow */\nimport opn from 'opn';\n\nimport {createLogger} from '../util/logger';\n\nconst log = createLogger(__filename);\n\nexport type DocsParams = {\n  noInput?: boolean,\n  shouldExitProgram?: boolean,\n}\n\nexport type DocsOptions = {\n  openUrl?: typeof opn,\n}\n\nexport const url = 'https://developer.mozilla.org/en-US/Add-ons' +\n  '/WebExtensions/Getting_started_with_web-ext';\n\nexport default function docs(\n  params: DocsParams, {openUrl = opn}: DocsOptions = {}\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    openUrl(url, (error) => {\n      if (error) {\n        log.debug(`Encountered an error while opening URL ${url}`, error);\n        reject(error);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n"],"sourceRoot":""}